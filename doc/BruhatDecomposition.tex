% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage[top=37mm,bottom=37mm,left=27mm,right=27mm]{geometry}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{ BruhatDecomposition \mbox{}}}\\
\vfill

\hypersetup{pdftitle= BruhatDecomposition }
\markright{\scriptsize \mbox{}\hfill  BruhatDecomposition  \hfill\mbox{}}
{\Huge \textbf{ Computes the Bruhat decomposition of matrices in classical groups. \mbox{}}}\\
\vfill

{\Huge  0.1 \mbox{}}\\[1cm]
{ 27 March 2020 \mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Daniel Rademacher\\
   \mbox{}}}\\
{\Large \textbf{ Alice Niemeyer\\
    \mbox{}}}\\
\hypersetup{pdfauthor= Daniel Rademacher\\
   ;  Alice Niemeyer\\
    }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ Daniel Rademacher\\
   }  Email: \href{mailto://rademacher@art.rwth-aachen.de} {\texttt{rademacher@art.rwth-aachen.de}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Daniel Rademacher\\
 Chair of Algebra and Representation Theory\\
 RWTH Aachen\\
 Pontdriesch 10/16\\
 52062 Aachen\\
 Germany\\
 \end{minipage}
}\\
{\mbox{}\\
\small \noindent \textbf{ Alice Niemeyer\\
    }  Email: \href{mailto://alice.niemeyer@mathb.rwth-aachen.de} {\texttt{alice.niemeyer@mathb.rwth-aachen.de}}\\
  Homepage: \href{http://www.math.rwth-aachen.de/~Alice.Niemeyer/} {\texttt{http://www.math.rwth-aachen.de/\texttt{\symbol{126}}Alice.Niemeyer/}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Alice Niemeyer\\
 Chair of Algebra and Representation Theory\\
 RWTH Aachen\\
 Pontdriesch 10/16\\
 52062 Aachen\\
 Germany\\
 \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 1 ]}}

\tableofcontents
\newpage

     
\chapter{\textcolor{Chapter }{Foreword}}\label{Chapter_Foreword}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X8248CBC383A4431E}{}
{
  

 Let $G$ be one of the classical groups SL, Sp, SU or SO over a finite field of size $q$ and dimension $d$. Let g be an element in G. We want to write $g = u_1 \cdot w \cdot u_2$ with $u_1$ and $u_2$ lower unitriangular matrices and $w$ a monomial matrix. 

 This is already implemented for: 
\begin{itemize}
\item  Special linear group (SL) (see Chapter \ref{Chapter_SpecialLinearGroup}) 
\item  Symplectic group (Sp) (see Chapter \ref{Chapter_SymplecticGroup}) 
\item  Special unitary group (SU) (see Chapter \ref{Chapter_SpecialUnitaryGroup}) 
\item  Special orthogonal group (SO) (see Chapter \ref{Chapter_SpecialOrthogonalGroup}) 
\end{itemize}
 
\section{\textcolor{Chapter }{Main Function}}\label{Section_MainFunction}
\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X7BBBB74882018953}{}
{
  

\subsection{\textcolor{Chapter }{BruhatDecomposition}}
\logpage{[ 1, 1, 1 ]}\nobreak
\hyperdef{L}{X7D8C913E787C6BD5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BruhatDecomposition({\mdseries\slshape g})\index{BruhatDecomposition@\texttt{BruhatDecomposition}}
\label{BruhatDecomposition}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
pgr (A SLP to compute $u_1,u_2,p_{sign}$ and $diag$ and the matrices $u_1, u_2, p_{sign}$ and $diag$ itself.) 



 Checks whether $g$ is an element of one of the classical groups in their natural representation.
If yes, the corresponding Bruhat decomposition of the group and the element $g$ is calculated. Otherwise the function prints a warning. }

 }

 }

   
\chapter{\textcolor{Chapter }{Special Orthogonal Group}}\label{Chapter_SpecialOrthogonalGroup}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7CDC26AF87C60FCA}{}
{
  

 This chapter deals with the special orthogonal group 
\section{\textcolor{Chapter }{Introduction and Quick Start of functions for SO}}\label{Section_LabelIntroductionAndQuickStartSO}
\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X8327C15D801A4A7A}{}
{
  

 TODO }

 
\section{\textcolor{Chapter }{Functions for SO}}\label{Section_LabelFunctionsSO}
\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X87D12E417B3D01D1}{}
{
  

\subsection{\textcolor{Chapter }{FindPrimePowerDecomposition}}
\logpage{[ 2, 2, 1 ]}\nobreak
\hyperdef{L}{X82BDB7147A3584E0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{FindPrimePowerDecomposition({\mdseries\slshape n})\index{FindPrimePowerDecomposition@\texttt{FindPrimePowerDecomposition}}
\label{FindPrimePowerDecomposition}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
$[a,b]$ ($a$ and $b$ are natural numbers such that $n-1= 2^a \cdot b$) 



 $n$: Natural number Computes two natural numbers $a$ and $b$ such that $n-1= 2^a \cdot b$. }

 

\subsection{\textcolor{Chapter }{LGOStandardGensSO}}
\logpage{[ 2, 2, 2 ]}\nobreak
\label{LGOStandardGensSOGroup}
\hyperdef{L}{X7A364C5F7C9118C1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LGOStandardGensSO({\mdseries\slshape d, q, e})\index{LGOStandardGensSO@\texttt{LGOStandardGensSO}}
\label{LGOStandardGensSO}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{{\textunderscore}{\textunderscore}LGOStandardGensSOPlus({\mdseries\slshape arg})\index{uScoreuScoreLGOStandardGensSOPlus@\texttt{{\textunderscore}{\textunderscore}}\-\texttt{L}\-\texttt{G}\-\texttt{O}\-\texttt{Standard}\-\texttt{Gens}\-\texttt{S}\-\texttt{O}\-\texttt{Plus}}
\label{uScoreuScoreLGOStandardGensSOPlus}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{{\textunderscore}{\textunderscore}LGOStandardGensSOCircle({\mdseries\slshape arg})\index{uScoreuScoreLGOStandardGensSOCircle@\texttt{{\textunderscore}{\textunderscore}}\-\texttt{L}\-\texttt{G}\-\texttt{O}\-\texttt{Standard}\-\texttt{Gens}\-\texttt{S}\-\texttt{O}\-\texttt{Circle}}
\label{uScoreuScoreLGOStandardGensSOCircle}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{{\textunderscore}{\textunderscore}LGOStandardGensSOMinus({\mdseries\slshape arg})\index{uScoreuScoreLGOStandardGensSOMinus@\texttt{{\textunderscore}{\textunderscore}}\-\texttt{L}\-\texttt{G}\-\texttt{O}\-\texttt{Standard}\-\texttt{Gens}\-\texttt{S}\-\texttt{O}\-\texttt{Minus}}
\label{uScoreuScoreLGOStandardGensSOMinus}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
stdgens (the LGO standard-generators of SO$(e,d,q)$) 



 $d$: the dimension of our matrices, $\newline$ $q$: A prime power $q = p^f$, where $\mathbb{F}_q$ ist the field whereover the matrices are defined. $q$ has to be odd $\newline$ $e$: 1 for plus type, 0 for zero type, -1 for minus type This function computes
the standard generators of SO as given by C. R. Leedham-Green and E. A.
O'Brien in "Constructive Recognition of Classical Groups in odd
characteristic" Depending on $e$ and $p$ (notice $q = p^f$ with p prime), the functions {\textunderscore}{\textunderscore}\texttt{LGOStandardGensSOPlus(d,q)}, {\textunderscore}{\textunderscore}\texttt{LGOStandardGensSOCircle(d,q)} or {\textunderscore}{\textunderscore}\texttt{LGOStandardGensSOMinus(d,q)} are called. 

 }

 

\subsection{\textcolor{Chapter }{LGOStandardGensOmega}}
\logpage{[ 2, 2, 3 ]}\nobreak
\label{LGOStandardGensOmegaGroup}
\hyperdef{L}{X81F934A87C60CF52}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LGOStandardGensOmega({\mdseries\slshape d, q, e})\index{LGOStandardGensOmega@\texttt{LGOStandardGensOmega}}
\label{LGOStandardGensOmega}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{{\textunderscore}{\textunderscore}LGOStandardGensOmegaPlus({\mdseries\slshape arg})\index{uScoreuScoreLGOStandardGensOmegaPlus@\texttt{{\textunderscore}{\textunderscore}}\-\texttt{L}\-\texttt{G}\-\texttt{O}\-\texttt{Standard}\-\texttt{Gens}\-\texttt{Omega}\-\texttt{Plus}}
\label{uScoreuScoreLGOStandardGensOmegaPlus}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{{\textunderscore}{\textunderscore}LGOStandardGensOmegaPlusEvenChar({\mdseries\slshape arg})\index{uScoreuScoreLGOStandardGensOmegaPlusEvenChar@\texttt{{\textunderscore}{\textunderscore}}\-\texttt{L}\-\texttt{G}\-\texttt{O}\-\texttt{Standard}\-\texttt{Gens}\-\texttt{Omega}\-\texttt{Plus}\-\texttt{Even}\-\texttt{Char}}
\label{uScoreuScoreLGOStandardGensOmegaPlusEvenChar}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{{\textunderscore}{\textunderscore}LGOStandardGensOmegaCircle({\mdseries\slshape arg})\index{uScoreuScoreLGOStandardGensOmegaCircle@\texttt{{\textunderscore}{\textunderscore}}\-\texttt{L}\-\texttt{G}\-\texttt{O}\-\texttt{Standard}\-\texttt{Gens}\-\texttt{Omega}\-\texttt{Circle}}
\label{uScoreuScoreLGOStandardGensOmegaCircle}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{{\textunderscore}{\textunderscore}LGOStandardGensOmegaCircleEvenChar({\mdseries\slshape arg})\index{uScoreuScoreLGOStandardGensOmegaCircleEvenChar@\texttt{{\textunderscore}{\textunderscore}}\-\texttt{L}\-\texttt{G}\-\texttt{O}\-\texttt{Standard}\-\texttt{Gens}\-\texttt{Omega}\-\texttt{Circle}\-\texttt{Even}\-\texttt{Char}}
\label{uScoreuScoreLGOStandardGensOmegaCircleEvenChar}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{{\textunderscore}{\textunderscore}LGOStandardGensOmegaMinus({\mdseries\slshape arg})\index{uScoreuScoreLGOStandardGensOmegaMinus@\texttt{{\textunderscore}{\textunderscore}}\-\texttt{L}\-\texttt{G}\-\texttt{O}\-\texttt{Standard}\-\texttt{Gens}\-\texttt{Omega}\-\texttt{Minus}}
\label{uScoreuScoreLGOStandardGensOmegaMinus}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{{\textunderscore}{\textunderscore}LGOStandardGensOmegaMinusEvenChar({\mdseries\slshape arg})\index{uScoreuScoreLGOStandardGensOmegaMinusEvenChar@\texttt{{\textunderscore}{\textunderscore}}\-\texttt{L}\-\texttt{G}\-\texttt{O}\-\texttt{Standard}\-\texttt{Gens}\-\texttt{Omega}\-\texttt{Minus}\-\texttt{Even}\-\texttt{Char}}
\label{uScoreuScoreLGOStandardGensOmegaMinusEvenChar}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
stdgens (the LGO standard-generators of $\Omega(e,d,q)$) 



 $d$: the dimension of our matrices, $\newline$ $q$: A prime power $q = p^f$, where $\mathbb{F}_q$ ist the field whereover the matrices are defined. $\newline$ $e$: 1 for plus type, 0 for zero type, -1 for minus type This function computes
the standard generators of $\Omega$ as given by C. R. Leedham-Green and E. A. O'Brien in "Constructive Recognition
of Classical Groups in odd characteristic" and "Constructive Recognition of
Classical Groups in even characteristic" Depending on $e$, the functions {\textunderscore}{\textunderscore}\texttt{LGOStandardGensOmegaPlus(d,q)}, {\textunderscore}{\textunderscore}\texttt{LGOStandardGensOmegaPlusEvenChar(d,q)}, {\textunderscore}{\textunderscore}\texttt{LGOStandardGensOmegaCircle(d,q)}, {\textunderscore}{\textunderscore}\texttt{LGOStandardGensOmegaCircleEvenChar(d,q)} {\textunderscore}{\textunderscore}\texttt{LGOStandardGensOmegaMinus(d,q)} or {\textunderscore}{\textunderscore}\texttt{LGOStandardGensOmegaMinusEvenChar(d,q)} are called. 

 }

 

\subsection{\textcolor{Chapter }{MSO}}
\logpage{[ 2, 2, 4 ]}\nobreak
\hyperdef{L}{X80EA73917E32D8C5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MSO({\mdseries\slshape d, q, e})\index{MSO@\texttt{MSO}}
\label{MSO}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
$G$ (where $G =$ SO$(e,d,q)$) 



 $d$: the dimension of our matrices, $\newline$ $q$: A prime power $q = p^f$, where $\mathbb{F}_q$ ist the field whereover the matrices are defined. $q$ has to be odd $\newline$ $e$: 1 for plus type, 0 for zero type, -1 for minus type $\newline$ This function returns the special orthogonal group of type e. The generators
of the group are the LGO standard generators and the size of the group is
already stored as an attribute. }

 

\subsection{\textcolor{Chapter }{UnitriangularDecompositionSOPlus}}
\logpage{[ 2, 2, 5 ]}\nobreak
\hyperdef{L}{X7830EA7980A6FF3C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnitriangularDecompositionSOPlus({\mdseries\slshape stdgens, g})\index{UnitriangularDecompositionSOPlus@\texttt{UnitriangularDecompositionSOPlus}}
\label{UnitriangularDecompositionSOPlus}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions yielding $u_1,u_2$ if evaluated as SLP), $[u_1,g,u_2]$ (The matrices of the Bruhat-Decomposition) 



 stdgens: The LGO standard-generators of SO$^+(d,q$) $\newline$ g: A matrix in SO$^+(d,q$) $\newline$ Computes the Unitriangular decomposition of the matrix $g$. }

 

\subsection{\textcolor{Chapter }{UnitriangularDecompositionSOCircle}}
\logpage{[ 2, 2, 6 ]}\nobreak
\hyperdef{L}{X82A1DB967FEDC567}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnitriangularDecompositionSOCircle({\mdseries\slshape stdgens, g})\index{UnitriangularDecompositionSOCircle@\texttt{UnitriangularDecompositionSOCircle}}
\label{UnitriangularDecompositionSOCircle}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions yielding $u_1,u_2$ if evaluated as SLP), $[u_1,g,u_2]$ (The matrices of the Bruhat-Decomposition) 



 stdgens: The LGO standard-generators of SO$^\circ(d,q$) $\newline$ g: A matrix in SO$^\circ(d,q$) $\newline$ Computes the Unitriangular decomposition of the matrix $g$. }

 

\subsection{\textcolor{Chapter }{UnitriangularDecompositionSOMinus}}
\logpage{[ 2, 2, 7 ]}\nobreak
\hyperdef{L}{X8490EA4C782CABC6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnitriangularDecompositionSOMinus({\mdseries\slshape stdgens, g})\index{UnitriangularDecompositionSOMinus@\texttt{UnitriangularDecompositionSOMinus}}
\label{UnitriangularDecompositionSOMinus}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions yielding $u_1,u_2$ if evaluated as SLP), $[u_1,g,u_2]$ (The matrices of the Bruhat-Decomposition) 



 stdgens: The LGO standard-generators of SO$^-(d,q$) $\newline$ g: A matrix in SO$^-(d,q$) $\newline$ Computes the Unitriangular decomposition of the matrix $g$. }

 

\subsection{\textcolor{Chapter }{MonomialSLPSOPlus}}
\logpage{[ 2, 2, 8 ]}\nobreak
\hyperdef{L}{X8585A1F9835E8D9E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MonomialSLPSOPlus({\mdseries\slshape stdgens, mat, slp})\index{MonomialSLPSOPlus@\texttt{MonomialSLPSOPlus}}
\label{MonomialSLPSOPlus}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate tmpvalue. If slp is also given as
input then this instructions are added to slp), [tmpvalue,diag] (tmpvalue is a
monomial matix such that tmpvalue*mat = diag where diag is a diagonal matrix) 



 stdgens: The LGO standard-generators of SO$^+(d,q)$ $\newline$ mat: A monomial matrix (ie $w$) in SO$^+(d,q)$ $\newline$ slp: An already existing list of instructions *optional $\newline$ In this function we will transform a monomial matrix $mat \in$ SO$^+(d,q)$ into a diagonal matrix diag. Using only the standard-generators $s,u,v$ this will lead to a monomial matrix tmpvalue and $tmpvalue^{-1} \cdot diag = mat$ (i.e. diag = tmpvalue*mat ). Furthermore we will return list slp of
instructions which will (when evaluated at the LGO standard-generators) yields
diag. }

 

\subsection{\textcolor{Chapter }{MonomialSLPSOCircle}}
\logpage{[ 2, 2, 9 ]}\nobreak
\hyperdef{L}{X80C538048400B1EE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MonomialSLPSOCircle({\mdseries\slshape stdgens, mat, slp})\index{MonomialSLPSOCircle@\texttt{MonomialSLPSOCircle}}
\label{MonomialSLPSOCircle}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate tmpvalue. If slp is also given as
input then this instructions are added to slp), [tmpvalue,diag] (tmpvalue is a
monomial matix such that tmpvalue*mat = diag where diag is a diagonal matrix) 



 stdgens: The LGO standard-generators of SO$^\circ(d,q)$ $\newline$ mat: A monomial matrix (ie $w$) in SO$^\circ(d,q)$ $\newline$ slp: An already existing list of instructions *optional $\newline$ In this function we will transform a monomial matrix $mat \in$ SO$^\circ(d,q)$ into a diagonal matrix diag. Using only the standard-generators $s,u,v$ this will lead to a monomial matrix tmpvalue and $tmpvalue^{-1} \cdot diag = mat$ (i.e. diag = tmpvalue*mat ). Furthermore we will return list slp of
instructions which will (when evaluated at the LGO standard-generators) yields
diag. }

 

\subsection{\textcolor{Chapter }{MonomialSLPSOMinus}}
\logpage{[ 2, 2, 10 ]}\nobreak
\hyperdef{L}{X7DE0729F7CDBD8A3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MonomialSLPSOMinus({\mdseries\slshape stdgens, mat, slp})\index{MonomialSLPSOMinus@\texttt{MonomialSLPSOMinus}}
\label{MonomialSLPSOMinus}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate tmpvalue. If slp is also given as
input then this instructions are added to slp), [tmpvalue,diag] (tmpvalue is a
monomial matix such that tmpvalue*mat = diag where diag is a diagonal matrix) 



 stdgens: The LGO standard-generators of SO$^-(d,q)$ $\newline$ mat: A monomial matrix (ie $w$) in SO$^-(d,q)$ $\newline$ slp: An already existing list of instructions *optional $\newline$ In this function we will transform a monomial matrix $mat \in$ SO$^-(d,q)$ into a diagonal matrix diag. Using only the standard-generators $s,u,v$ this will lead to a monomial matrix tmpvalue and $tmpvalue^{-1} \cdot diag = mat$ (i.e. diag = tmpvalue*mat ). Furthermore we will return list slp of
instructions which will (when evaluated at the LGO standard-generators) yields
diag. }

 

\subsection{\textcolor{Chapter }{FindCorrectCycel}}
\logpage{[ 2, 2, 11 ]}\nobreak
\hyperdef{L}{X86DF2E8C82D722C0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{FindCorrectCycel({\mdseries\slshape perm, j})\index{FindCorrectCycel@\texttt{FindCorrectCycel}}
\label{FindCorrectCycel}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A permutation 



 perm: A list of cycles $\newline$ j: A natural number $\newline$ This is a help function for \texttt{MonomialSLPSOPlus}. Checks whether there is a cycle $c$ in perm such that $j^c \neq j$. If there is such an cycle, the cycle is returned. Otherwise the identity
permutation is returned. }

 

\subsection{\textcolor{Chapter }{TestPermutationProd}}
\logpage{[ 2, 2, 12 ]}\nobreak
\hyperdef{L}{X84A7229F85FE68A0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{TestPermutationProd({\mdseries\slshape op, np, l, n})\index{TestPermutationProd@\texttt{TestPermutationProd}}
\label{TestPermutationProd}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true or false 



 $op$: A list of cycle $\newline$ $np$: A list of cycle $\newline$ $l$: A list of natural numbers $\newline$ $n$: A natural number $\newline$ This is a help function for \texttt{MonomialSLPSOPlus}. This function checks whether the new permutation $np$ destorys an already considered element of $op$. The already considered elements are stored in $l$. }

 

\subsection{\textcolor{Chapter }{TestPermutationProd2}}
\logpage{[ 2, 2, 13 ]}\nobreak
\hyperdef{L}{X87520D1B785FDD77}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{TestPermutationProd2({\mdseries\slshape op, np, tn, l, n})\index{TestPermutationProd2@\texttt{TestPermutationProd2}}
\label{TestPermutationProd2}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true or false 



 $op$: A list of cycle $\newline$ $np$: A list of cycle $\newline$ $tn$: A natural number $\newline$ $l$: A list of natural numbers $\newline$ $n$: A natural number $\newline$ This is a help function for \texttt{MonomialSLPSOPlus}. This function checks whether the probability to continue with $np$ is higher than with $op$ depending on the element $tn$. }

 

\subsection{\textcolor{Chapter }{MonomialMatrixToEasyForm}}
\logpage{[ 2, 2, 14 ]}\nobreak
\hyperdef{L}{X869E879B8459D8AB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MonomialMatrixToEasyForm({\mdseries\slshape M})\index{MonomialMatrixToEasyForm@\texttt{MonomialMatrixToEasyForm}}
\label{MonomialMatrixToEasyForm}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
[list,perm] (list is a list of the non-zero elements of each column of $M$, perm is the permutation corresponding to $M$) 



 $M$: A monomial matrix $\newline$ This is a help function for \texttt{MonomialSLPSOPlus} and \texttt{MonomialSLPSOCircle}. This function calcultes a list of size 2. The first entry is a list of the
non-zero elements of each column of $M$. The second entry is a permutation which corresponds to $M$ as a permutation matrix. }

 

\subsection{\textcolor{Chapter }{EasyFormToMonomialMatrix}}
\logpage{[ 2, 2, 15 ]}\nobreak
\hyperdef{L}{X84C9FB4A7A78DA87}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{EasyFormToMonomialMatrix({\mdseries\slshape tupel, n, fld})\index{EasyFormToMonomialMatrix@\texttt{EasyFormToMonomialMatrix}}
\label{EasyFormToMonomialMatrix}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
$M$ (A monomial matrix) 



 $tupel$: A 2-tupel as in \texttt{MonomialMatrixToEasyForm} $\newline$ $n$: A natural number $\newline$ $fld$: A finite field $\newline$ This is a help function for \texttt{MonomialSLPSOPlus} and \texttt{MonomialSLPSOCircle}. This function computes a monomial matrix $M$ of size $n$ over $fld$ such that \texttt{MonomialMatrixToEasyForm}$(M) = tupel $. }

 

\subsection{\textcolor{Chapter }{MultiplicationOfEasyForm}}
\logpage{[ 2, 2, 16 ]}\nobreak
\hyperdef{L}{X793DBD9D84572E3A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MultiplicationOfEasyForm({\mdseries\slshape tupel1, tupel2})\index{MultiplicationOfEasyForm@\texttt{MultiplicationOfEasyForm}}
\label{MultiplicationOfEasyForm}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
[list,perm] (list is a list of the non-zero elements of each column of $M$, perm is the permutation corresponding to $M$) 



 $tupel1$: A 2-tupel as in \texttt{MonomialMatrixToEasyForm} $\newline$ $tupel2$: A 2-tupel as in \texttt{MonomialMatrixToEasyForm} $\newline$ This is a help function for \texttt{MonomialSLPSOPlus} and \texttt{MonomialSLPSOCircle}. Let $M_1$ be a monomial matrix which corresponds to $tupel1$ and $M_2$ be a monomial matrix which corresponds to $tupel2$. This function computes a tupel [list,perm] such that for the corresponding
monomial matrix $M$ holds $M = M_1 \cdot M_2$. }

 

\subsection{\textcolor{Chapter }{DiagSLPSOPlus}}
\logpage{[ 2, 2, 17 ]}\nobreak
\hyperdef{L}{X7D4E9B3380224189}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagSLPSOPlus({\mdseries\slshape stdgens, diag, slp})\index{DiagSLPSOPlus@\texttt{DiagSLPSOPlus}}
\label{DiagSLPSOPlus}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate diag if slp was Input then this
instructions are added to slp) 



 stdgens: The LGO standard-generators of SO$^+(d,q)$ $\newline$ diag: A diagonal matrix (eg diag) in SO$^+(d,q)$ $\newline$ slp: An already existing list of instructions *optional $\newline$ Writes a list of instructions which evaluated with LGO standard-generators
yield the diagonal matrix of the input. }

 

\subsection{\textcolor{Chapter }{DiagSLPSOCircle}}
\logpage{[ 2, 2, 18 ]}\nobreak
\hyperdef{L}{X83275C91811427F9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagSLPSOCircle({\mdseries\slshape stdgens, diag, slp})\index{DiagSLPSOCircle@\texttt{DiagSLPSOCircle}}
\label{DiagSLPSOCircle}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate diag if slp was Input then this
instructions are added to slp) 



 stdgens: The LGO standard-generators of SO$^\circ(d,q)$ $\newline$ diag: A diagonal matrix (eg diag) in SO$^\circ(d,q)$ $\newline$ slp: An already existing list of instructions *optional $\newline$ Writes a list of instructions which evaluated with LGO standard-generators
yield the diagonal matrix of the input. }

 

\subsection{\textcolor{Chapter }{DiagSLPSOMinus}}
\logpage{[ 2, 2, 19 ]}\nobreak
\hyperdef{L}{X79639AC17F3F7B2D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagSLPSOMinus({\mdseries\slshape stdgens, diag, slp})\index{DiagSLPSOMinus@\texttt{DiagSLPSOMinus}}
\label{DiagSLPSOMinus}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate diag if slp was Input then this
instructions are added to slp) 



 stdgens: The LGO standard-generators of SO$^-(d,q)$ $\newline$ diag: A diagonal matrix (eg diag) in SO$^-(d,q)$ $\newline$ slp: An already existing list of instructions *optional $\newline$ Writes a list of instructions which evaluated with LGO standard-generators
yield the diagonal matrix of the input. }

 

\subsection{\textcolor{Chapter }{BruhatDecompositionSO}}
\logpage{[ 2, 2, 20 ]}\nobreak
\hyperdef{L}{X867B3F907A32A656}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BruhatDecompositionSO({\mdseries\slshape stdgens, g})\index{BruhatDecompositionSO@\texttt{BruhatDecompositionSO}}
\label{BruhatDecompositionSO}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
pgr (A SLP to compute $u_1,u_2,p_{sign}$ and $diag$ and the matrices $u_1, u_2, p_{sign}$ and $diag$ itself.) 



 stdgens: The LGO standard-generators $ \newline $ g: A matrix in SO$(e,d,q)$ $ \newline $ Uses \texttt{UnitriangularDecompositionSOPlus()}, \texttt{MonomialSLPSOPlus()} and \texttt{DiagSLPSOPlus()} for the plus type, \texttt{UnitriangularDecompositionSOCircle()}, \texttt{MonomialSLPSOCircle()} and \texttt{DiagSLPSOCircle()} for the circle type or \texttt{UnitriangularDecompositionSOMinus()}, \texttt{MonomialSLPSOMinus()} and \texttt{DiagSLPSOMinus()} for the minus type to write a matrix $g \in$ SO$(e,d,q)$ as $g = u_1^{-1} \cdot p_{sign} \cdot diag \cdot u_2^{-1}$ where $u_1,u_2$ are lower unitriangular matrices, $p_{sign}$ is a monomial matrix and $diag$ a diagonal matrix. It furthermore yields an SLP that returns the above
matrices if evaluated with the LGO standard-generators. }

 }

 }

   
\chapter{\textcolor{Chapter }{Special Linear Group}}\label{Chapter_SpecialLinearGroup}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X80F0E9FA7D0AC6F3}{}
{
  

 This chapter deals with the special linear group 
\section{\textcolor{Chapter }{Introduction and Quick Start of functions for SL}}\label{Section_LabelIntroductionAndQuickStartSL}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X7AB754468477692C}{}
{
  Concept: This implementation follows the ideas of "Straight-line programs with
memory and matrix Bruhat decomposition" by Alice Niemeyer, Tomasz Popiel and
Cheryl Praeger. In the following all references will mean this paper and in
case we differ from this paper (due to readability or bug-fixing) this will
also be remarked. $\smallskip$ 

 Let $g \in$ SL$(d,p^f)$ Bruhat Decomposition computes $g = u_1 \cdot w \cdot u_2$, where 
\begin{itemize}
\item  $u_1,u_2$ are lower triangular matrices 
\item  $w$ is monomial matrix $\smallskip$ 
\end{itemize}
 

 In this algorithm we want to compute the Bruhat-Decomposition of $g$ and give $g$ (respectively $u_1,w$ and $u_2$) as word in the so called "LGO standard generators" (REF TODO). $\smallskip$ 

 1) While computing $u_1$ (resp $u_2$) with some kind of Gau{\ss}-Algorithm, we express the matrices as product of
so called transvections 
\begin{itemize}
\item  For $1 \leq j < i \leq d$: $t_{i,j}(\alpha)$ is the matrix T with 1-entries on diagonal, $T_{i,j} = \alpha$, 0 elsewhere $\newline$ Each $t_{i,j}(\alpha)$ can be computed from $t_{2,1}(\alpha)$ via recursion, where we have to distinguish the odd and even dimensons (p12
Lemma 4.2). This again can be expressed as a product of $t_{2,1}(\omega^\ell)$ (where omega is a primitive element and $0 \leq \ell < f$). The transvections as words in the standard generators are described in (p12
Lemma 4.2). $\newline$ This yields a decomposition of $u_1$ and $u_2$ in standard generators. $\smallskip$ 
\end{itemize}
 

 2) In a further step we will decompose the monomial Matrix $w$ in a signed permutation matrix p{\textunderscore}sign and a diagonal Matrix
diag. ( How to associate p{\textunderscore}sign with a product of generators
is further described in (PART I b) and (PART III) ) $\smallskip$ 

 3) The last step is the decomposition of the diagonal Matrix in 2) as word in
the standard generators. $\smallskip$ 

 We won't do this matrix multiplications directly, but write them in a list to
evaluate in a StraightLineProgram. (Section 2) Although described differently
in the paper, we sometimes will allow instructions to multiply more than two
elements (eg during conjugating). This doesn't affect the optimality of an slp
much, but higly increases the readability of our implementation. $\smallskip$ }

 
\section{\textcolor{Chapter }{Implemented Subfunctions (Part I)}}\label{Section_LabelSubfunctionsPart1}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X81E72B8282AC6ED6}{}
{
  

 Later we will need some additional functions. Why they are needed and where
they are needed is described here. 

 

 
\begin{itemize}
\item  \texttt{MakeSLP()}: After the \texttt{BruhatDecompositionSL()} we get a list of instructions to calculate the matrices we want using the LGO
standard generators. \texttt{MakeSLP()} is used to get a SLP out of these instructions.
\item  \texttt{CoefficientsPrimitiveElement()}: It expresses an element w in a field fld as a linear combination of a
Primitive Element. This is important for the transvections. (TODO Add
Reference!) 
\item  \texttt{MyPermutationMat()}: Turns a permutation into a permutation matrix. We need it to calculate the
LGO standard generator. 
\item  \texttt{LGOStandardGensSL()}: This function computes the standard generators of SL as given by C. R.
Leedham-Green and E. A. O'Brien in "Constructive Recognition of Classical
Groups in odd characteristic". (TODO Add Reference!) 

 
\item  \texttt{HighestSlotOfSLP()}: The following function determines the highest slot of a SLP constructed from
the list slp will write in. This is important to glue SLPs together. 
\item  \texttt{MatToWreathProd()} and \texttt{WreathProdToMat()}: In \texttt{PermSLP()} [\ref{PermSLP}] we want to transform the monomial matrix $w$ given by \texttt{UnipotentDecomposition()} into a diagonal matrix. (The exact procedure is described in \texttt{PermSLP()} [\ref{PermSLP}])

 Since multiplying the LGO standard-generators $s,v$ and $x$ not only involves permutations but we also have to consider which non-zero
entries are $+1$ and which $-1$, we want to associate this matrices with permutations on $2d$ points. (cf. Wreath-Product)

 

 $[s,v,x] \to Sym(2d), M \to $ \texttt{Mwr} where $i^{Mwr} = j$ and $(i+d)^{Mwr}= j+d$ if $ M_{i,j} = 1$ and $i^{Mwr} = j+d$ and $(i+d)^{Mwr}= j$ if $M_{i,j} = -1$ for $1 \leq i \leq d$.

 

 Due to their relation to wreath-products, we will call denote the image of a
matrix \texttt{M}$ \in [s,v,x] $ by \texttt{Mwr}. 

 

 In fact the association from \texttt{MatToWreathProd()} [\ref{MatToWreathProd}] is an isomorphism and we can associate to each permutation we compute during \texttt{PermSLP()} [\ref{PermSLP}] a signed permutation matrix (a monomial matrix with only $+1$ and $-1$ as non-zero entries). 

 $M_{i,j} = 1$ if $i^{Mwr} = j \leq d$ and $M_{i,j} = -1$ if $i^{Mwr} = j+d$ 
\item  \texttt{AEM()}: Write instructions for Ancient Egyptian Multiplication in slp. At several
occasions we will need to compute a high power of some value saved in a memory
slot.
\item  \texttt{TestIfMonomial()}: Tests if a given matrix M is monomial matrix. We use it to decide whether we
are already finished in \texttt{UnipotentDecomposition()}.
\end{itemize}
 

 For some functions also exist a NC version. See [\ref{Section_LabelNCVersionSL}]. 

 }

 
\section{\textcolor{Chapter }{UnipotentDecomposition (Part II - a)}}\label{Section_LabelUnipotentDecomposition2a}
\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X83E0C06C7AB80DD4}{}
{
  

 In this section is the \texttt{UnipotentDecomposition()} described. This method is used to compute the Unitriangular decomposition of
the matrix $g$. [\ref{UnipotentDecomposition}] 

 

 For this we use five local functions in the \texttt{UnipotentDecomposition()}. They are \texttt{TransvecAtAlpha()}, \texttt{ShiftTransvections()}, \texttt{FastShiftTransvections()}, \texttt{BackShiftTransvections()} and \texttt{FastBackShiftTransvections()}. 

 The difference to \texttt{UnipotentDecompositionWithTi()} [\ref{Section_LabelUnipotentDecomposition2b}] is that this version won't store all the transvections $t_{i,i-1}(\omega^l)$. This will increase the runtime but reduce the memory usage by $(d-3) \cdot f$ compared to the \texttt{UnipotentDecompositionWithTi()}.

 

 The function can be called for example by 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@d := 3;;|
  !gapprompt@gap>| !gapinput@q := 5;;|
  !gapprompt@gap>| !gapinput@L := SL(d, q);;|
  !gapprompt@gap>| !gapinput@m := PseudoRandom(L);;|
  !gapprompt@gap>| !gapinput@stdgens := LGOStandardGensSL(d, q);;|
  !gapprompt@gap>| !gapinput@UnipotentDecomposition( stdgens, g);;|
\end{Verbatim}
 

 }

 
\section{\textcolor{Chapter }{UnipotentDecomposition saving Transvections (Part II - b)}}\label{Section_LabelUnipotentDecomposition2b}
\logpage{[ 3, 4, 0 ]}
\hyperdef{L}{X8119AABE86F3606D}{}
{
  

 In this section is the \texttt{UnipotentDecompositionWithTi()} described. This method is used to compute the Unitriangular decomposition of
the matrix $g$. [\ref{UnipotentDecompositionWithTi}] 

 

 In this version we will store all the transvections $t_{i,i-1}(\omega^l)$. This will increase the memory usage by $(d-3) \cdot f$ but reduce runtime.

 

 In \texttt{UnipotentDecompositionWithTi()} we use two local functions. They are \texttt{TransvectionAtAlpha()} and \texttt{ComputeAllTransvections()}. 

 

 The function can be called for example by 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@d := 3;;|
  !gapprompt@gap>| !gapinput@q := 5;;|
  !gapprompt@gap>| !gapinput@L := SL(d, q);;|
  !gapprompt@gap>| !gapinput@m := PseudoRandom(L);;|
  !gapprompt@gap>| !gapinput@stdgens := LGOStandardGensSL(d, q);;|
  !gapprompt@gap>| !gapinput@UnipotentDecompositionWithTi( stdgens, g);;|
\end{Verbatim}
 

 }

 
\section{\textcolor{Chapter }{Decomposing the Monomial Matrix (Part III)}}\label{Section_LabelDecomposingMonomialMatrices}
\logpage{[ 3, 5, 0 ]}
\hyperdef{L}{X80C69E33879354C8}{}
{
  

 We use three functions to decompose the monomial matrix $w$ we get from \texttt{UnipotentDecomposition()}. They are: 
\begin{itemize}
\item  \texttt{PermutationMonomialMatrix()}: Find the permutation (in Sym(d) corresponding to the monomial matrix $w$) and $diag$ a diagonal matrix, where $diag[i]$ is the non-zero entry of row $i$. [\ref{PermutationMonomialMatrix}] 
\item  \texttt{PermSLP()}: In this function we will transform a monomial matrix $w \in $SL$(d,q)$ into a diagonal matrix $diag$. Using only the standard-generators $s,v,x$. This will lead to a monomial matrix $p_{sign}$ with only $\pm 1$ in non-zero entries and $p_{sign} \cdot diag = w$ (i.e. $diag = (p_{sign})^{-1} \cdot w$ ).

 Furthermore we will return list \texttt{slp} of instructions which will (when evaluated at the LGO standard-generators)
yield $diag$. 

 It is sufficient for $diag$ to be diagonal, if the permutation associated with $w$ (i.e. $i^{\pi_w} = j$ if $M_{i,j} \neq 0$) is the inverse of the permutation associated to $p_{sign}$ (again only to Sym($d$) ).

 

 In \texttt{PermSLP()} we thus transform $\pi_w$ to $()$ using only $\{ \pi_s, \pi_v, \pi_x \}$. In order to know $diag$ without computing all matrix multiplications, (we don't know the signs of $p_{sign}$), we compute a second permutation simultaneously (here using their
identification with permutations in Sym$(2d)$ and identifying $\{ \pi_s, \pi_v, \pi_x \}$ with $\{s,v,x\}$ ). [\ref{PermSLP}] 
\item  \texttt{DiagonalDecomposition()}: Writes a list of instructions which evaluated on LGO standard-generators
yield the diagonal matrix of the input. [\ref{DiagonalDecomposition}]
\end{itemize}
 

 To these three functions is also a NC version implemented. See [\ref{Section_LabelNCVersionSL}]. 

 }

 
\section{\textcolor{Chapter }{Main Function (Part IV)}}\label{Section_LabelMainFunctionSL}
\logpage{[ 3, 6, 0 ]}
\hyperdef{L}{X7D8EB03B8022F892}{}
{
  

 In \texttt{BruhatDecompositionSL()} [\ref{BruhatDecompositionSL}] we put everything together. We use the three functions \texttt{UnipotentDecomposition()} [\ref{UnipotentDecomposition}], \texttt{PermSLP()} [\ref{PermSLP}] and \texttt{DiagonalDecomposition()} [\ref{DiagonalDecomposition}] to compute matrices with $u_1^{-1} \cdot p_{sign} \cdot diag \cdot u_2^{-1} = g$ and a SLP \texttt{pgr} that computes these matrices with the LGO standard generators.

 

 Here is an exampel: 
\begin{Verbatim}[commandchars=@|A,fontsize=\small,frame=single,label=Example]
  @gapprompt|gap>A @gapinput|mat := [ [ Z(5)^2, Z(5)^0, Z(5)^2 ],A
  @gapprompt|>A @gapinput|            [ Z(5)^3, 0*Z(5), 0*Z(5) ],A
  @gapprompt|>A @gapinput|            [ 0*Z(5), Z(5)^2, Z(5)^2 ] ];;#!A
  @gapprompt|gap>A @gapinput|L := BruhatDecompositionSL(LGOStandardGensSL(3,5), mat);A
  @gapprompt|gap>A @gapinput|result := ResultOfStraightLineProgram(L[1], LGOStandardGensSL(3,5));A
\end{Verbatim}
 

 \texttt{BruhatDecompositionSLWithTi()} [\ref{BruhatDecompositionSLWithTi}] works like \texttt{BruhatDecompositionSL()} [\ref{BruhatDecompositionSL}] but uses \texttt{UnipotentDecompositionWithTi()} [\ref{UnipotentDecompositionWithTi}] instead of \texttt{UnipotentDecomposition()} [\ref{UnipotentDecomposition}]. 

 

 You can use it in the same way like \texttt{BruhatDecompositionSL()}: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@mat := [ [ Z(5)^2, Z(5)^0, Z(5)^2 ],|
  !gapprompt@>| !gapinput@            [ Z(5)^3, 0*Z(5), 0*Z(5) ],|
  !gapprompt@>| !gapinput@            [ 0*Z(5), Z(5)^2, Z(5)^2 ] ];;|
  !gapprompt@gap>| !gapinput@L := BruhatDecompositionSLWithTi(LGOStandardGensSL(3,5), mat);|
  !gapprompt@gap>| !gapinput@result := ResultOfStraightLineProgram(L[1], LGOStandardGensSL(3,5));|
\end{Verbatim}
 

 To both functions is also a NC version implemented. See [\ref{Section_LabelNCVersionSL}]. 

 }

 
\section{\textcolor{Chapter }{NC Version}}\label{Section_LabelNCVersionSL}
\logpage{[ 3, 7, 0 ]}
\hyperdef{L}{X864D6CAB7CE3BBF0}{}
{
  

 Here is the NC version of the Bruhat Decomposition described. In all
implemented functions are all used functions replaced through their NC version
(if one exists). Moreover are all checks from functions of
MyBruhatDecomposition removed.

 

 These functions has been modified by this actions and got a NC Version: 
\begin{itemize}
\item \texttt{MakeSLP()}[\ref{MakeSLP}] $\to$ \texttt{MakeSLPNC()}[\ref{MakeSLPNC}] (uses the NC version of \texttt{StraightLineProgram})
\item \texttt{MyPermutationMat()} [\ref{MyPermutationMat}] $\to$ \texttt{MyPermutationMatNC()} [\ref{MyPermutationMatNC}] (uses the NC version of \texttt{ConvertToMatrixRep})
\item \texttt{LGOStandardGensSL()} [\ref{LGOStandardGensSL}] $\to$ \texttt{LGOStandardGensSLNC()} [\ref{LGOStandardGensSLNC}] (uses the NC version of \texttt{MyPermutationMat()})
\item \texttt{MatToWreathProd()} [\ref{MatToWreathProd}] $\to$ \texttt{MatToWreathProdNC()} [\ref{MatToWreathProdNC}] (no checks for user input)
\item \texttt{TestIfMonomial()} [\ref{TestIfMonomial}] $\to$ \texttt{TestIfMonomialNC()} [\ref{TestIfMonomialNC}] (no checks for user input)
\item \texttt{UnipotentDecomposition()} [\ref{UnipotentDecomposition}] $\to$ \texttt{UnipotentDecompositionNC()} [\ref{UnipotentDecompositionNC}] (no checks for user input)
\item \texttt{UnipotentDecompositionWithTi()} [\ref{UnipotentDecompositionWithTi}] $\to$ \texttt{UnipotentDecompositionWithTiNC()} [\ref{UnipotentDecompositionWithTiNC}] (no checks for user input)
\item \texttt{PermutationMonomialMatrix()} [\ref{PermutationMonomialMatrix}] $\to$ \texttt{PermutationMonomialMatrixNC()} [\ref{PermutationMonomialMatrixNC}] (no checks for user input)
\item \texttt{PermSLP()} [\ref{PermSLP}] $\to$ \texttt{PermSLPNC()} [\ref{PermSLPNC}] (no checks for unser input and uses \texttt{PermutationMonomialMatrixNC()})
\item \texttt{DiagonalDecomposition()} [\ref{DiagonalDecomposition}] $\to$ \texttt{DiagonalDecompositionNC()} [\ref{DiagonalDecompositionNC}] (no checks for user input)
\item \texttt{BruhatDecompositionSL()} [\ref{BruhatDecompositionSL}] $\to$ \texttt{BruhatDecompositionSLNC()} [\ref{BruhatDecompositionSLNC}] (uses \texttt{UnipotentDecompositionNC()}, \texttt{PermSLPNC()} and \texttt{DiagonalDecompositionNC})
\item \texttt{BruhatDecompositionSLWithTi()} [\ref{BruhatDecompositionSLWithTi}] $\to$ \texttt{BruhatDecompositionSLWithTiNC()} [\ref{BruhatDecompositionSLWithTiNC}] (uses \texttt{UnipotentDecompositionWithTiNC()}, \texttt{PermSLPNC()} and \texttt{DiagonalDecompositionNC()})
\end{itemize}
 }

 
\section{\textcolor{Chapter }{Functions for SL}}\label{Section_LabelFunctionsSL}
\logpage{[ 3, 8, 0 ]}
\hyperdef{L}{X7E41BB5A79A18A9E}{}
{
  

\subsection{\textcolor{Chapter }{MakeSLP}}
\logpage{[ 3, 8, 1 ]}\nobreak
\label{MakeSLPGroup}
\hyperdef{L}{X7AFC8C7D78152151}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MakeSLP({\mdseries\slshape slp, genlen})\index{MakeSLP@\texttt{MakeSLP}}
\label{MakeSLP}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MakeSLPNC({\mdseries\slshape arg})\index{MakeSLPNC@\texttt{MakeSLPNC}}
\label{MakeSLPNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
An SLP using the instructions of slp and genlen inputs 



 slp: A list of instructions for a straight-line program, $\newline$ genlen: The number of inputs for our SLP (ie the number of generators ) $\newline$ To increase readability, the lists slp as defined later (see Unipotent-,
Diagonal-, BruhatDecompositionSL and PermSLP) start with [1,1],[2,1],.. [5,1].
However this represents the LGO standard- generators and is the input of our
straight-line program. Defining and SLP we thus have to exclude this
instructions from our list. 

 }

 

\subsection{\textcolor{Chapter }{CoefficientsPrimitiveElement}}
\logpage{[ 3, 8, 2 ]}\nobreak
\hyperdef{L}{X828EE9DF7B60A03E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CoefficientsPrimitiveElement({\mdseries\slshape fld, alpha})\index{CoefficientsPrimitiveElement@\texttt{CoefficientsPrimitiveElement}}
\label{CoefficientsPrimitiveElement}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
Coefficients (A vector c sth for omega primitive element alpha = sum c[i]
omega\texttt{\symbol{94}}(i-1)) 



 fld: A field, $\newline$ alpha: An element of fld $\newline$ The following function has been written by Thomas Breuer. It expresses an
element alpha in a field fld as a linear combination of a Primitive Element. }

 

\subsection{\textcolor{Chapter }{MyPermutationMat}}
\logpage{[ 3, 8, 3 ]}\nobreak
\label{MyPermutationMatGroup}
\hyperdef{L}{X7B138D977A8B7189}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MyPermutationMat({\mdseries\slshape perm, dim, fld})\index{MyPermutationMat@\texttt{MyPermutationMat}}
\label{MyPermutationMat}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MyPermutationMatNC({\mdseries\slshape arg})\index{MyPermutationMatNC@\texttt{MyPermutationMatNC}}
\label{MyPermutationMatNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
The permutation matrix of perm over $M_{d x d}(fld)$ (ie $res_{i,j} = One(fld)$ if $i^{perm} = j$) 



 perm: A permutation, $\newline$ dim: A natural number, $\newline$ fld: A field $\newline$ Given a permutation an integer $d > 0$ and a field fld, this function computes the permutation matrix $P$ in $M_{d x d}(fld)$. 

 }

 

\subsection{\textcolor{Chapter }{LGOStandardGensSL}}
\logpage{[ 3, 8, 4 ]}\nobreak
\label{LGOStandardGensSLGroup}
\hyperdef{L}{X83A6D94479A8BD79}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LGOStandardGensSL({\mdseries\slshape d, q})\index{LGOStandardGensSL@\texttt{LGOStandardGensSL}}
\label{LGOStandardGensSL}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LGOStandardGensSLNC({\mdseries\slshape arg})\index{LGOStandardGensSLNC@\texttt{LGOStandardGensSLNC}}
\label{LGOStandardGensSLNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
stdgens (the LGO standard-generators of SL$(d,q)$) 



 $d$: the dimension of our matrix, $\newline$ $q$: A prime power $q = p^f$, where $F_q$ ist the field whereover the matrices are defined $\newline$ This function computes the standard generators of SL as given by C. R.
Leedham-Green and E. A. O'Brien in "Constructive Recognition of Classical
Groups in odd characteristic" (This matrices can also be found in the paper ch
3.1 ps 6-7) 

 }

 

\subsection{\textcolor{Chapter }{HighestSlotOfSLP}}
\logpage{[ 3, 8, 5 ]}\nobreak
\hyperdef{L}{X7E4A850D7AAC4293}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{HighestSlotOfSLP({\mdseries\slshape slp})\index{HighestSlotOfSLP@\texttt{HighestSlotOfSLP}}
\label{HighestSlotOfSLP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
highestslot (The number of slots this SLP will need if evaluated) 



 slp: A list of instructions satisfying the properties for an SLP $\newline$ The following function determines the highest slot a SLP constructed from the
list slp will write in. }

 

\subsection{\textcolor{Chapter }{MatToWreathProd}}
\logpage{[ 3, 8, 6 ]}\nobreak
\label{MatToWreathProdGroup}
\hyperdef{L}{X7D23BD4E79542F4B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MatToWreathProd({\mdseries\slshape M})\index{MatToWreathProd@\texttt{MatToWreathProd}}
\label{MatToWreathProd}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MatToWreathProdNC({\mdseries\slshape arg})\index{MatToWreathProdNC@\texttt{MatToWreathProdNC}}
\label{MatToWreathProdNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
perm (the permutation Mwr) 



 M: A monomial matrix with only +1 and -1 entries $\newline$ In PermSLP we want to transform the monomial matrix w given by
UnipotentDecomposition() into a diagonal matrix. (The exact procedure is
described in PermSLP) Since multiplying the LGO standard-generators $s,v$ and $x$ not only involves permutations but we also have to consider which non-zero
entries are +1 and which -1, we want to associate this matrices with
permutations on $2d$ points. (cf Wreath-Product) $ \langle s,v,x \rangle \rightarrow$ Sym$(2d), M \rightarrow Mwr$ where $i^{Mwr} = j $ and $(i+d)^{Mwr}= j+d$ if $M_{i,j} = 1$ and $i^{Mwr} = j+d$ and $(i+d)^{Mwr}= j$ if $M_{i,j} = -1$ for $1\leq i\leq d$ Due to their relation to wreath-products, we will call denote the image of a
matrix $M \in \langle s,v,x \rangle $ by Mwr 

 }

 

\subsection{\textcolor{Chapter }{WreathProdToMat}}
\logpage{[ 3, 8, 7 ]}\nobreak
\hyperdef{L}{X87F98DEC85E3FDAA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{WreathProdToMat({\mdseries\slshape perm, dim, fld})\index{WreathProdToMat@\texttt{WreathProdToMat}}
\label{WreathProdToMat}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
res (The Matrix M satisfying the below properties) 



 perm: A permutation in Sym($2d$) sth. ${{i,i+d}}_1: 1 \leq i \leq d $ are blocks, $\newline$ dim: The dimension of the matrix we want perm send to, $\newline$ fld: The field whereover the matrix is defined. $\newline$ In fact the association above is an isomorphism and we can associate to each
permutation we compute during PermSLP a unique monomial matrix whose non-zero
entries are +1 or -1. $M_{i,j} = 1$ if $i^{Mwr} = j \leq d $ and $M_{i,j} = -1$ if $i^{Mwr} = j+d$ }

 

\subsection{\textcolor{Chapter }{AEM}}
\logpage{[ 3, 8, 8 ]}\nobreak
\hyperdef{L}{X7F52B1487F587A1C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{AEM({\mdseries\slshape spos, respos, tmppos, k})\index{AEM@\texttt{AEM}}
\label{AEM}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
instr (Lines of an SLP that will (when evaluated) take the value b saved in
spos and write b\texttt{\symbol{94}}k in respos) 



 AEM (Ancient Egytian Multiplication) $\newline$ spos: The memory slot, where a value b is saved in, $\newline$ respos: The memory slot we want the exponentation to be written in, $\newline$ tmppos: A memory slot for temporary results, $\newline$ k: An integer $\newline$ At several occasions we will need to compute a high power of some value saved
in a memory slot. For this purpose there is a variaton of AEM implemented
below. Remarks: tmpos and respos must differ. If spos = respos or spos = tmpos
it will be overwritten. }

 

\subsection{\textcolor{Chapter }{TestIfMonomial}}
\logpage{[ 3, 8, 9 ]}\nobreak
\label{TestIfMonomialGroup}
\hyperdef{L}{X7C7736A682A7A0D5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{TestIfMonomial({\mdseries\slshape M})\index{TestIfMonomial@\texttt{TestIfMonomial}}
\label{TestIfMonomial}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{TestIfMonomialNC({\mdseries\slshape arg})\index{TestIfMonomialNC@\texttt{TestIfMonomialNC}}
\label{TestIfMonomialNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
True if $M$ is a monomial matrix, otherwise false. 



 $M$: A Matrix $\newline$ Tests if a given matrix $M$ is a monomial matrix. There is function in GAP, however it does not seem to
work for SL$(d,q)$. 

 }

 

\subsection{\textcolor{Chapter }{Transvections2}}
\logpage{[ 3, 8, 10 ]}\nobreak
\hyperdef{L}{X85C18012862F6FAD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Transvections2({\mdseries\slshape stdgens, omega, slp, pos})\index{Transvections2@\texttt{Transvections2}}
\label{Transvections2}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp: The list of instruction with additional instructions writing $t_{2,1}(\omega^\ell)$ in Slot pos[l+1] $0 \leq \ell \leq f-1$. 



 stdgens: The LGO standard-generators of SL$(d,q)$ $\newline$ omega: A primitive element of GF($q$) $\newline$ slp: A list of instructions $\newline$ pos: A list of numbers, denoting where to save the transvections $t_{2,1}(\omega^\ell)$ for $0 \leq \ell \leq f-1$ $\newline$ Let stdgens be the list of standard generators for SL$(d,p^f)$ and let omega be a primitive element of G($p^f$). This function computes $T_2 := \{ t_{2,1}(\omega^\ell) \mid 0 \leq \ell \leq f-1 \}$ Record what we do in slp This function coincides with eq (6) p12. }

 

\subsection{\textcolor{Chapter }{UnipotentDecomposition}}
\logpage{[ 3, 8, 11 ]}\nobreak
\label{UnipotentDecompositionGroup}
\hyperdef{L}{X8779E9377C892EB9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnipotentDecomposition({\mdseries\slshape stdgens, g})\index{UnipotentDecomposition@\texttt{UnipotentDecomposition}}
\label{UnipotentDecomposition}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnipotentDecompositionNC({\mdseries\slshape arg})\index{UnipotentDecompositionNC@\texttt{UnipotentDecompositionNC}}
\label{UnipotentDecompositionNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions yielding $u_1,u_2$ if evaluated as SLP), $[u_1,g,u_2]$ (The matrices of the Bruhat-Decomposition) 



 stdgens: The LGO standard-generators $\newline$ g: A matrix in SL($d,q$) $\newline$ Computes the Unitriangular decomposition of the matrix $g$. 

 }

 

\subsection{\textcolor{Chapter }{UnipotentDecompositionWithTi}}
\logpage{[ 3, 8, 12 ]}\nobreak
\label{UnipotentDecompositionWithTiGroup}
\hyperdef{L}{X7D30168E7F1DE65C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnipotentDecompositionWithTi({\mdseries\slshape stdgens, g})\index{UnipotentDecompositionWithTi@\texttt{UnipotentDecompositionWithTi}}
\label{UnipotentDecompositionWithTi}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnipotentDecompositionWithTiNC({\mdseries\slshape arg})\index{UnipotentDecompositionWithTiNC@\texttt{UnipotentDecompositionWithTiNC}}
\label{UnipotentDecompositionWithTiNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions yielding $u_1,u_2$ if evaluated as SLP), $[u_1,g,u_2]$ (The matrices of the Bruhat-Decomposition) 



 stdgens: The LGO standard-generators $\newline$ g: A matrix in SL($d,q$) $\newline$ Computes the Bruhat decomposition of the matrix $g$, given the standard generators for the group. In this version we will store
all the transvections $t_{i,i-1}(\omega^\ell)$. this will increase the memory usage by $(d-3) \cdot f$ but reduce the runtime. 

 }

 

\subsection{\textcolor{Chapter }{PermutationMonomialMatrix}}
\logpage{[ 3, 8, 13 ]}\nobreak
\label{PermutationMonomialMatrixGroup}
\hyperdef{L}{X7A75AB0D8104691A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PermutationMonomialMatrix({\mdseries\slshape M})\index{PermutationMonomialMatrix@\texttt{PermutationMonomialMatrix}}
\label{PermutationMonomialMatrix}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PermutationMonomialMatrixNC({\mdseries\slshape arg})\index{PermutationMonomialMatrixNC@\texttt{PermutationMonomialMatrixNC}}
\label{PermutationMonomialMatrixNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
diag (The vector of non-zero entries, where diag$[i]$ is the non-zero entry of row $i$.), perm (The permutation associated to $M$, i.e. $i^{perm} = j$ if $M_{i,j}$ is not 0) 



 M: A monomial matrix. $\newline$ Find the permutation (in Sym($d$)) corresponding to the input monomial matrix. 

 }

 

\subsection{\textcolor{Chapter }{PermSLP}}
\logpage{[ 3, 8, 14 ]}\nobreak
\label{PermSLPGroup}
\hyperdef{L}{X79A14A5D8507B0CD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PermSLP({\mdseries\slshape stdgens, mat, slp})\index{PermSLP@\texttt{PermSLP}}
\label{PermSLP}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PermSLPNC({\mdseries\slshape arg})\index{PermSLPNC@\texttt{PermSLPNC}}
\label{PermSLPNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate p{\textunderscore}sign if slp was
Input then this instructions are added to slp), p{\textunderscore}sign (The
signed permutation matrix), mat (The diagonal matrix diag) 



 stdgens: The LGO standard-generators $\newline$ mat: A monomial matrix (ie $w$) $\newline$ slp: An already existing list of instructions *optional $\newline$ In this function we will transform a monomial matrix $w \in$ SL$(d,q)$ into a diagonal matrix diag. Using only the standard-generators $s,v,x$ this will lead to a monomial matrix p{\textunderscore}sign with only +-1 in
non-zero entries and p{\textunderscore}sign*diag = $w$ (i.e. diag = p{\textunderscore}sign\texttt{\symbol{94}}-1*w ). Furthermore we
will return list slp of instructions which will (when evaluated at the LGO
standard-generators) yield diag. $\newline$ It is sufficient for diag to be diagonal, if the permutation associated with $w$ (i.e. $ i^\pi_w = j $ if $ M_{i,j} $ not 0) is the inverse of the permutation associated to p{\textunderscore}sign
(again only to Sym($ d $) ) $\newline$ In PermSLP we thus transform $\pi_w$ to () using only $\{ \pi_s, \pi_v, \pi_x \}$ In order to know diag without computing all matrix multiplications, (we don't
know the signs of p{\textunderscore}sign), we compute a second permutation
simultaneously (here using their identification with permutations in Sym($2d$) and identifying $\{ \pi_s, \pi_v, \pi_x \}$ with $\{ s,v,x \}$ ) 

 }

 

\subsection{\textcolor{Chapter }{DiagonalDecomposition}}
\logpage{[ 3, 8, 15 ]}\nobreak
\label{DiagonalDecompositionGroup}
\hyperdef{L}{X85F12FD9859DE12D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagonalDecomposition({\mdseries\slshape stdgens, diag, slp})\index{DiagonalDecomposition@\texttt{DiagonalDecomposition}}
\label{DiagonalDecomposition}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagonalDecompositionNC({\mdseries\slshape arg})\index{DiagonalDecompositionNC@\texttt{DiagonalDecompositionNC}}
\label{DiagonalDecompositionNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate diag if slp was Input then this
instructions are added to slp), hres (The the identity matrix) 



 stdgens: The LGO standard-generators $\newline$ diag: A diagonal matrix (eg diag) $\newline$ slp: An already existing list of instructions *optional $\newline$ Writes a list of instructions which evaluated on LGO standard-generators yield
the diagonal matrix of the input. 

 }

 

\subsection{\textcolor{Chapter }{BruhatDecompositionSL}}
\logpage{[ 3, 8, 16 ]}\nobreak
\label{BruhatDecompositionSLGroup}
\hyperdef{L}{X7FEBAA8B7D834E78}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BruhatDecompositionSL({\mdseries\slshape stdgens, g})\index{BruhatDecompositionSL@\texttt{BruhatDecompositionSL}}
\label{BruhatDecompositionSL}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BruhatDecompositionSLNC({\mdseries\slshape arg})\index{BruhatDecompositionSLNC@\texttt{BruhatDecompositionSLNC}}
\label{BruhatDecompositionSLNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
pgr (A SLP to compute $u_1,u_2,p_{sign}$ and $diag$ and the matrices $u_1, u_2, p_{sign}$ and $diag$ itself.) 



 stdgens: The LGO standard-generators $\newline$ g: A matrix in SL$(d,q)$ $\newline$ Uses \texttt{UnipotentDecomposition()}, \texttt{PermSLP()} and \texttt{DiagonalDecomposition()} to write a matrix $g \in$ SL$(d,q)$ as $g = u_1^{-1} \cdot p_{sign} \cdot diag \cdot u_2^{-1}$ where $u_1,u_2$ are lower unitriangular matrices, $p_{sign}$ is a monomial matrix with only +1 and -1 as non-zero entries and $diag$ a diagonal matrix. It furthermore yields an SLP that returns the above
matrices if evaluated with the LGO standard-generators. 

 }

 

\subsection{\textcolor{Chapter }{BruhatDecompositionSLWithTi}}
\logpage{[ 3, 8, 17 ]}\nobreak
\label{BruhatDecompositionSLWithTiGroup}
\hyperdef{L}{X7EFA686D79709746}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BruhatDecompositionSLWithTi({\mdseries\slshape stdgens, g})\index{BruhatDecompositionSLWithTi@\texttt{BruhatDecompositionSLWithTi}}
\label{BruhatDecompositionSLWithTi}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BruhatDecompositionSLWithTiNC({\mdseries\slshape arg})\index{BruhatDecompositionSLWithTiNC@\texttt{BruhatDecompositionSLWithTiNC}}
\label{BruhatDecompositionSLWithTiNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
pgr (A SLP to compute $u_1,u_2,p_{sign}$ and $diag$ and the matrices $u_1, u_2, p_{sign}$ and $diag$ itself.) 



 stdgens: The LGO standard-generators $\newline$ g: A matrix in SL$(d,q)$ $\newline$ As \texttt{BruhatDecompositionSL()} but replaces \texttt{UnipotentDecomposition()} by \texttt{UnipotentDecompositionWithTi()}. 

 }

 }

 }

   
\chapter{\textcolor{Chapter }{Special Unitary Group}}\label{Chapter_SpecialUnitaryGroup}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X7E224B548754A5C1}{}
{
  

 This chapter deals with the special unitary group 
\section{\textcolor{Chapter }{Introduction and Quick Start of functions for SU}}\label{Section_LabelIntroductionAndQuickStartSU}
\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X7CF1EECA821C5DFF}{}
{
  

 TODO }

 
\section{\textcolor{Chapter }{Functions for SU}}\label{Section_LabelFunctionsSU}
\logpage{[ 4, 2, 0 ]}
\hyperdef{L}{X780701D67A14499A}{}
{
  

\subsection{\textcolor{Chapter }{MakePermutationMat}}
\logpage{[ 4, 2, 1 ]}\nobreak
\hyperdef{L}{X79FFD8F1865D0CEE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MakePermutationMat({\mdseries\slshape perm, dim, fld})\index{MakePermutationMat@\texttt{MakePermutationMat}}
\label{MakePermutationMat}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
The permutation matrix of perm over $M_{d x d}(fld)$ (ie $res_{i,j} = One(fld)$ if $i^{perm} = j$) 



 perm: A permutation, $\newline$ dim: A natural number, $\newline$ fld: A field $\newline$ This is the same function as MyPermutationMat. }

 

\subsection{\textcolor{Chapter }{LGOStandardGensSU}}
\logpage{[ 4, 2, 2 ]}\nobreak
\hyperdef{L}{X85E063C87EC6CCA3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LGOStandardGensSU({\mdseries\slshape d, q})\index{LGOStandardGensSU@\texttt{LGOStandardGensSU}}
\label{LGOStandardGensSU}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
stdgens (the LGO standard-generators of SU$(d,q)$) 



 $d$: The dimension of our matrix. $\newline$ $q$: A prime power $q = p^f$, where $F_q$ ist the field whereover the matrices are defined $\newline$ This function computes the standard generators of SU as given by C. R.
Leedham-Green and E. A. O'Brien in "Constructive Recognition of Classical
Groups in odd characteristic". If q is even, \texttt{LGOStandardGensSUEvenChar(d,q)} is called automatically. }

 

\subsection{\textcolor{Chapter }{LGOStandardGensSUEvenChar}}
\logpage{[ 4, 2, 3 ]}\nobreak
\hyperdef{L}{X7BC3A5EF792D770B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LGOStandardGensSUEvenChar({\mdseries\slshape d, q})\index{LGOStandardGensSUEvenChar@\texttt{LGOStandardGensSUEvenChar}}
\label{LGOStandardGensSUEvenChar}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
stdgens (the LGO standard-generators of SU$(d,q)$) for q even 



 $d$: The dimension of our matrix. $\newline$ $q$: A 2 power $q = 2^f$, where $F_q$ ist the field whereover the matrices are defined $\newline$ This function computes the standard generators of Sp as given by C. R.
Leedham-Green and E. A. O'Brien in "Constructive Recognition of Classical
Groups in even characteristic" }

 

\subsection{\textcolor{Chapter }{CoefficientsPrimitiveElementS}}
\logpage{[ 4, 2, 4 ]}\nobreak
\hyperdef{L}{X793211108385A4F2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CoefficientsPrimitiveElementS({\mdseries\slshape fld, alpha, basis})\index{CoefficientsPrimitiveElementS@\texttt{CoefficientsPrimitiveElementS}}
\label{CoefficientsPrimitiveElementS}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
Coefficients (A vector c sth alpha = sum c[i] b[i]) 



 fld: A field, $\newline$ alpha: An element of fld $\newline$ basis: A $F_p$ basis of fld $\newline$ It expresses an element alpha in a field fld as a linear combination of the
basis elements. }

 

\subsection{\textcolor{Chapter }{UnitriangularDecompositionSUEven}}
\logpage{[ 4, 2, 5 ]}\nobreak
\hyperdef{L}{X7F6ECD7380D6D2A0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnitriangularDecompositionSUEven({\mdseries\slshape stdgens, g})\index{UnitriangularDecompositionSUEven@\texttt{UnitriangularDecompositionSUEven}}
\label{UnitriangularDecompositionSUEven}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions yielding $u_1,u_2$ if evaluated as SLP), $[u_1,g,u_2]$ (The matrices of the Bruhat-Decomposition) 



 stdgens: The LGO standard-generators $\newline$ g: A matrix in SU($d,q$) where d is even and q is odd $\newline$ Computes the Unitriangular decomposition of the matrix $g$. }

 

\subsection{\textcolor{Chapter }{UnitriangularDecompositionSUEvenAndEvenChar}}
\logpage{[ 4, 2, 6 ]}\nobreak
\hyperdef{L}{X8728AEF07EBF62A7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnitriangularDecompositionSUEvenAndEvenChar({\mdseries\slshape stdgens, g})\index{UnitriangularDecompositionSUEvenAndEvenChar@\texttt{Unitriangular}\-\texttt{Decomposition}\-\texttt{S}\-\texttt{U}\-\texttt{Even}\-\texttt{And}\-\texttt{Even}\-\texttt{Char}}
\label{UnitriangularDecompositionSUEvenAndEvenChar}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions yielding $u_1,u_2$ if evaluated as SLP), $[u_1,g,u_2]$ (The matrices of the Bruhat-Decomposition) 



 stdgens: The LGO standard-generators $\newline$ g: A matrix in SU($d,q$) where d is even and q is even $\newline$ Computes the Unitriangular decomposition of the matrix $g$. }

 

\subsection{\textcolor{Chapter }{UnitriangularDecompositionSUOdd}}
\logpage{[ 4, 2, 7 ]}\nobreak
\hyperdef{L}{X85795AD27BFECB19}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnitriangularDecompositionSUOdd({\mdseries\slshape stdgens, g})\index{UnitriangularDecompositionSUOdd@\texttt{UnitriangularDecompositionSUOdd}}
\label{UnitriangularDecompositionSUOdd}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions yielding $u_1,u_2$ if evaluated as SLP), $[u_1,g,u_2]$ (The matrices of the Bruhat-Decomposition) 



 stdgens: The LGO standard-generators $\newline$ g: A matrix in SU($d,q$) where d is odd and q is odd $\newline$ Computes the Unitriangular decomposition of the matrix $g$. }

 

\subsection{\textcolor{Chapter }{UnitriangularDecompositionSUOddAndEvenChar}}
\logpage{[ 4, 2, 8 ]}\nobreak
\hyperdef{L}{X824D12B4847B0C2D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnitriangularDecompositionSUOddAndEvenChar({\mdseries\slshape stdgens, g})\index{UnitriangularDecompositionSUOddAndEvenChar@\texttt{Unitriangular}\-\texttt{Decomposition}\-\texttt{S}\-\texttt{U}\-\texttt{Odd}\-\texttt{And}\-\texttt{Even}\-\texttt{Char}}
\label{UnitriangularDecompositionSUOddAndEvenChar}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions yielding $u_1,u_2$ if evaluated as SLP), $[u_1,g,u_2]$ (The matrices of the Bruhat-Decomposition) 



 stdgens: The LGO standard-generators $\newline$ g: A matrix in SU($d,q$) where d is odd and q is even $\newline$ Computes the Unitriangular decomposition of the matrix $g$. }

 

\subsection{\textcolor{Chapter }{UnitriangularDecompositionSU}}
\logpage{[ 4, 2, 9 ]}\nobreak
\hyperdef{L}{X79E30D6E7DD8291D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnitriangularDecompositionSU({\mdseries\slshape stdgens, g})\index{UnitriangularDecompositionSU@\texttt{UnitriangularDecompositionSU}}
\label{UnitriangularDecompositionSU}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions yielding $u_1,u_2$ if evaluated as SLP), $[u_1,g,u_2]$ (The matrices of the Bruhat-Decomposition) 



 stdgens: The LGO standard-generators $\newline$ g: A matrix in SU($d,q$) $\newline$ Computes the Unitriangular decomposition of the matrix $g$. Depending on q and d the correct function of \texttt{UnitriangularDecompositionSUEven}, \texttt{UnitriangularDecompositionSUOdd} and \texttt{UnitriangularDecompositionSUOdd} is choosen. }

 

\subsection{\textcolor{Chapter }{MonomialSLPSUOdd}}
\logpage{[ 4, 2, 10 ]}\nobreak
\hyperdef{L}{X7B8E470078522BF4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MonomialSLPSUOdd({\mdseries\slshape stdgens, mat, slp})\index{MonomialSLPSUOdd@\texttt{MonomialSLPSUOdd}}
\label{MonomialSLPSUOdd}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate tmpvalue. If slp is also given as
input then this instructions are added to slp), [tmpvalue,diag] (tmpvalue is a
monomial matix such that tmpvalue*mat = diag where diag is a diagonal matrix) 



 stdgens: The LGO standard-generators $\newline$ mat: A monomial matrix (ie $w$) in SU$(d,q)$ with $d$ odd and $q$ odd $\newline$ slp: An already existing list of instructions *optional $\newline$ In this function we will transform a monomial matrix $mat \in$ SU$(d,q)$ with $d$ even and $q$ odd into a diagonal matrix diag. Using only the standard-generators $s,u,v$ this will lead to a monomial matrix tmpvalue and $tmpvalue^{-1} \cdot diag = mat$ (i.e. diag = tmpvalue*mat ). Furthermore we will return list slp of
instructions which will (when evaluated at the LGO standard-generators) yields
diag. }

 

\subsection{\textcolor{Chapter }{MonomialSLPSUOddAndEvenChar}}
\logpage{[ 4, 2, 11 ]}\nobreak
\hyperdef{L}{X8572518B7A2389C7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MonomialSLPSUOddAndEvenChar({\mdseries\slshape stdgens, mat, slp})\index{MonomialSLPSUOddAndEvenChar@\texttt{MonomialSLPSUOddAndEvenChar}}
\label{MonomialSLPSUOddAndEvenChar}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate tmpvalue. If slp is also given as
input then this instructions are added to slp), [tmpvalue,diag] (tmpvalue is a
monomial matix such that tmpvalue*mat = diag where diag is a diagonal matrix) 



 stdgens: The LGO standard-generators $\newline$ mat: A monomial matrix (ie $w$) in SU$(d,q)$ with $d$ odd and $q$ even $\newline$ slp: An already existing list of instructions *optional $\newline$ In this function we will transform a monomial matrix $mat \in$ SU$(d,q)$ with $d$ even and $q$ odd into a diagonal matrix diag. Using only the standard-generators $s,u,v$ this will lead to a monomial matrix tmpvalue and $tmpvalue^{-1} \cdot diag = mat$ (i.e. diag = tmpvalue*mat ). Furthermore we will return list slp of
instructions which will (when evaluated at the LGO standard-generators) yields
diag. }

 

\subsection{\textcolor{Chapter }{MonomialSLPSUEvenAndEvenChar}}
\logpage{[ 4, 2, 12 ]}\nobreak
\hyperdef{L}{X7B843D9B85F2F6E2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MonomialSLPSUEvenAndEvenChar({\mdseries\slshape stdgens, mat, slp})\index{MonomialSLPSUEvenAndEvenChar@\texttt{MonomialSLPSUEvenAndEvenChar}}
\label{MonomialSLPSUEvenAndEvenChar}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate tmpvalue. If slp is also given as
input then this instructions are added to slp), [tmpvalue,diag] (tmpvalue is a
monomial matix such that tmpvalue*mat = diag where diag is a diagonal matrix) 



 stdgens: The LGO standard-generators $\newline$ mat: A monomial matrix (ie $w$) in SU$(d,q)$ with $d$ even and $q$ even $\newline$ slp: An already existing list of instructions *optional $\newline$ In this function we will transform a monomial matrix $mat \in$ SU$(d,q)$ with $d$ even and $q$ even into a diagonal matrix diag. Using only the standard-generators $s,u,v$ this will lead to a monomial matrix tmpvalue and $tmpvalue^{-1} \cdot diag = mat$ (i.e. diag = tmpvalue*mat ). Furthermore we will return list slp of
instructions which will (when evaluated at the LGO standard-generators) yields
diag. }

 

\subsection{\textcolor{Chapter }{MonomialSLPSUEven}}
\logpage{[ 4, 2, 13 ]}\nobreak
\hyperdef{L}{X82DB86F379904ADB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MonomialSLPSUEven({\mdseries\slshape stdgens, mat, slp})\index{MonomialSLPSUEven@\texttt{MonomialSLPSUEven}}
\label{MonomialSLPSUEven}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate tmpvalue. If slp is also given as
input then this instructions are added to slp), [tmpvalue,diag] (tmpvalue is a
monomial matix such that tmpvalue*mat = diag where diag is a diagonal matrix) 



 stdgens: The LGO standard-generators $\newline$ mat: A monomial matrix (ie $w$) in SU$(d,q)$ with $d$ even and $q$ odd $\newline$ slp: An already existing list of instructions *optional $\newline$ In this function we will transform a monomial matrix $mat \in$ SU$(d,q)$ with $d$ odd and $q$ odd into a diagonal matrix diag. Using only the standard-generators $s,u,v$ this will lead to a monomial matrix tmpvalue and $tmpvalue^{-1} \cdot diag = mat$ (i.e. diag = tmpvalue*mat ). Furthermore we will return list slp of
instructions which will (when evaluated at the LGO standard-generators) yields
diag. }

 

\subsection{\textcolor{Chapter }{CheckContinue}}
\logpage{[ 4, 2, 14 ]}\nobreak
\hyperdef{L}{X7A69AFAE8637E93F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CheckContinue({\mdseries\slshape perm, m})\index{CheckContinue@\texttt{CheckContinue}}
\label{CheckContinue}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
True or false 



 perm: A permutation $\newline$ m: A natural number. If this function is called by \texttt{MonomialSLPSU} then $m = \frac{d}{2}$ or $m = \frac{(d-1)}{2}$ $\newline$ This is a help function for \texttt{MonomialSLPSU}. This function checks whether for all cycle c of perm holds:
LargestMovedPoint(c) $\leq$ m or SmallestMovedPoint(c) {\textgreater} m. Notice that this is the condition
for the main loop of \texttt{MonomialSLPSU}. }

 

\subsection{\textcolor{Chapter }{CycleFromPermutation}}
\logpage{[ 4, 2, 15 ]}\nobreak
\hyperdef{L}{X86D4EC5985EDD4FF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CycleFromPermutation({\mdseries\slshape g})\index{CycleFromPermutation@\texttt{CycleFromPermutation}}
\label{CycleFromPermutation}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
List of permutations 



 g: A permutation $\newline$ This is a help function for \texttt{MonomialSLPSUOdd}. This function computes the cycles of g and stores them in the output list. }

 

\subsection{\textcolor{Chapter }{CycleFromListMine}}
\logpage{[ 4, 2, 16 ]}\nobreak
\hyperdef{L}{X7A03D6777C11BB61}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CycleFromListMine({\mdseries\slshape nc, h})\index{CycleFromListMine@\texttt{CycleFromListMine}}
\label{CycleFromListMine}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
TODO 



 nc: A subset of [1,...,h] $\newline$ h: A natural number (the largest moved point of a permutation) $\newline$ This is a help function for \texttt{CycleFromPermutation}. This function computes a cycle in Sym{\textunderscore}h which corresponds to
nc. }

 

\subsection{\textcolor{Chapter }{DiagSLPSUOdd}}
\logpage{[ 4, 2, 17 ]}\nobreak
\hyperdef{L}{X7D83424581E15CB1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagSLPSUOdd({\mdseries\slshape stdgens, diag, slp})\index{DiagSLPSUOdd@\texttt{DiagSLPSUOdd}}
\label{DiagSLPSUOdd}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate diag if slp was Input then this
instructions are added to slp) 



 stdgens: The LGO standard-generators $\newline$ diag: A diagonal matrix (eg diag) in SU$(d,q)$ with $d$ odd and $q$ odd $\newline$ slp: An already existing list of instructions *optional $\newline$ Writes a list of instructions which evaluated with LGO standard-generators
yield the diagonal matrix of the input. }

 

\subsection{\textcolor{Chapter }{DiagSLPSUOddAndEvenChar}}
\logpage{[ 4, 2, 18 ]}\nobreak
\hyperdef{L}{X809FE2927E47AD26}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagSLPSUOddAndEvenChar({\mdseries\slshape stdgens, diag, slp})\index{DiagSLPSUOddAndEvenChar@\texttt{DiagSLPSUOddAndEvenChar}}
\label{DiagSLPSUOddAndEvenChar}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate diag if slp was Input then this
instructions are added to slp) 



 stdgens: The LGO standard-generators $\newline$ diag: A diagonal matrix (eg diag) in SU$(d,q)$ with $d$ odd and $q$ even $\newline$ slp: An already existing list of instructions *optional $\newline$ Writes a list of instructions which evaluated with LGO standard-generators
yield the diagonal matrix of the input. }

 

\subsection{\textcolor{Chapter }{DiagSLPSU}}
\logpage{[ 4, 2, 19 ]}\nobreak
\hyperdef{L}{X78315BFA86EC337A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagSLPSU({\mdseries\slshape stdgens, diag, slp})\index{DiagSLPSU@\texttt{DiagSLPSU}}
\label{DiagSLPSU}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate diag if slp was Input then this
instructions are added to slp) 



 stdgens: The LGO standard-generators $\newline$ diag: A diagonal matrix (eg diag) in SU$(d,q)$ $\newline$ slp: An already existing list of instructions *optional $\newline$ Writes a list of instructions which evaluated with LGO standard-generators
yield the diagonal matrix of the input. Depending on q and d the correct
function of \texttt{DiagSLPSUEven}, \texttt{DiagSLPSUEvenAndEvenChar} and \texttt{DiagSLPSUOdd} is choosen. }

 

\subsection{\textcolor{Chapter }{DiagSLPSUEven}}
\logpage{[ 4, 2, 20 ]}\nobreak
\hyperdef{L}{X7A10BC39849272DC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagSLPSUEven({\mdseries\slshape stdgens, diag, slp})\index{DiagSLPSUEven@\texttt{DiagSLPSUEven}}
\label{DiagSLPSUEven}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate diag if slp was Input then this
instructions are added to slp) 



 stdgens: The LGO standard-generators $\newline$ diag: A diagonal matrix (eg diag) in SU$(d,q)$ with $d$ even and $q$ odd $\newline$ slp: An already existing list of instructions *optional $\newline$ Writes a list of instructions which evaluated with LGO standard-generators
yield the diagonal matrix of the input. }

 

\subsection{\textcolor{Chapter }{DiagSLPSUEvenAndEvenChar}}
\logpage{[ 4, 2, 21 ]}\nobreak
\hyperdef{L}{X7A61CF0E7FE601EE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagSLPSUEvenAndEvenChar({\mdseries\slshape stdgens, diag, slp})\index{DiagSLPSUEvenAndEvenChar@\texttt{DiagSLPSUEvenAndEvenChar}}
\label{DiagSLPSUEvenAndEvenChar}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate diag if slp was Input then this
instructions are added to slp) 



 stdgens: The LGO standard-generators $\newline$ diag: A diagonal matrix (eg diag) in SU$(d,q)$ with $d$ even and $q$ even $\newline$ slp: An already existing list of instructions *optional $\newline$ Writes a list of instructions which evaluated with LGO standard-generators
yield the diagonal matrix of the input. }

 

\subsection{\textcolor{Chapter }{BruhatDecompositionSU}}
\logpage{[ 4, 2, 22 ]}\nobreak
\hyperdef{L}{X79AD1007829F87F8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BruhatDecompositionSU({\mdseries\slshape stdgens, g})\index{BruhatDecompositionSU@\texttt{BruhatDecompositionSU}}
\label{BruhatDecompositionSU}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
pgr (A SLP to compute $u_1,u_2,p_{sign}$ and $diag$ and the matrices $u_1, u_2, p_{sign}$ and $diag$ itself.) 



 stdgens: The LGO standard-generators $ \newline $ g: A matrix in SU$(d,q)$ $ \newline $ Uses \texttt{UnitriangularDecompositionSU()}, \texttt{MonomialSLPSU()} and \texttt{DiagSLPSU()} to write a matrix $g \in$ SU$(d,q)$ as $g = u_1^{-1} \cdot p_{sign} \cdot diag \cdot u_2^{-1}$ where $u_1,u_2$ are lower unitriangular matrices, $p_{sign}$ is a monomial matrix and $diag$ a diagonal matrix. It furthermore yields an SLP that returns the above
matrices if evaluated with the LGO standard-generators. }

 }

 }

   
\chapter{\textcolor{Chapter }{Symplectic Group}}\label{Chapter_SymplecticGroup}
\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X82394E0281653B43}{}
{
  

 This chapter deals with the symplectic group 
\section{\textcolor{Chapter }{Introduction and Quick Start of functions for Sp}}\label{Section_LabelIntroductionAndQuickStartSp}
\logpage{[ 5, 1, 0 ]}
\hyperdef{L}{X7BF741827EAB3805}{}
{
  

 TODO }

 
\section{\textcolor{Chapter }{Functions for Sp}}\label{Section_LabelFunctionsSp}
\logpage{[ 5, 2, 0 ]}
\hyperdef{L}{X7F01AE9E7DB1D44B}{}
{
  

\subsection{\textcolor{Chapter }{LGOStandardGensSp}}
\logpage{[ 5, 2, 1 ]}\nobreak
\hyperdef{L}{X82E6CC80818C226B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LGOStandardGensSp({\mdseries\slshape d, q})\index{LGOStandardGensSp@\texttt{LGOStandardGensSp}}
\label{LGOStandardGensSp}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
stdgens (the LGO standard-generators of Sp$(d,q)$) 



 $d$: The dimension of our matrix. Notice that $d$ needs to be even for symplectic groups. $\newline$ $q$: A prime power $q = p^f$, where $F_q$ ist the field whereover the matrices are defined $\newline$ This function computes the standard generators of Sp as given by C. R.
Leedham-Green and E. A. O'Brien in "Constructive Recognition of Classical
Groups in odd characteristic" }

 

\subsection{\textcolor{Chapter }{LGOStandardGensSpEvenChar}}
\logpage{[ 5, 2, 2 ]}\nobreak
\hyperdef{L}{X7F6AD1BB866799C3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LGOStandardGensSpEvenChar({\mdseries\slshape d, q})\index{LGOStandardGensSpEvenChar@\texttt{LGOStandardGensSpEvenChar}}
\label{LGOStandardGensSpEvenChar}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
stdgens (the LGO standard-generators of Sp$(d,q)$) for q even 



 $d$: The dimension of our matrix. Notice that $d$ needs to be even for symplectic groups. $\newline$ $q$: A 2 power $q = 2^f$, where $F_q$ ist the field whereover the matrices are defined $\newline$ This function computes the standard generators of Sp as given by C. R.
Leedham-Green and E. A. O'Brien in "Constructive Recognition of Classical
Groups in even characteristic" }

 

\subsection{\textcolor{Chapter }{UnitriangularDecompositionSp}}
\logpage{[ 5, 2, 3 ]}\nobreak
\hyperdef{L}{X7EE5A2267DAE098B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnitriangularDecompositionSp({\mdseries\slshape stdgens, g})\index{UnitriangularDecompositionSp@\texttt{UnitriangularDecompositionSp}}
\label{UnitriangularDecompositionSp}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions yielding $u_1,u_2$ if evaluated as SLP), $[u_1,g,u_2]$ (The matrices of the Bruhat-Decomposition) 



 stdgens: The LGO standard-generators $\newline$ g: A matrix in Sp($d,q$) and q odd $\newline$ Computes the Unitriangular decomposition of the matrix $g$. }

 

\subsection{\textcolor{Chapter }{UnitriangularDecompositionSpEvenChar}}
\logpage{[ 5, 2, 4 ]}\nobreak
\hyperdef{L}{X82B6052F786B0B4F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnitriangularDecompositionSpEvenChar({\mdseries\slshape stdgens, g})\index{UnitriangularDecompositionSpEvenChar@\texttt{Unitriangular}\-\texttt{Decomposition}\-\texttt{Sp}\-\texttt{Even}\-\texttt{Char}}
\label{UnitriangularDecompositionSpEvenChar}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions yielding $u_1,u_2$ if evaluated as SLP), $[u_1,g,u_2]$ (The matrices of the Bruhat-Decomposition) 



 stdgens: The LGO standard-generators $\newline$ g: A matrix in Sp($d,q$) and q even $\newline$ Computes the Unitriangular decomposition of the matrix $g$. }

 

\subsection{\textcolor{Chapter }{MonomialSLPSp}}
\logpage{[ 5, 2, 5 ]}\nobreak
\hyperdef{L}{X84615263789182BE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MonomialSLPSp({\mdseries\slshape stdgens, mat, slp})\index{MonomialSLPSp@\texttt{MonomialSLPSp}}
\label{MonomialSLPSp}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate tmpvalue. If slp is also given as
input then this instructions are added to slp), [tmpvalue,diag] (tmpvalue is a
monomial matix such that tmpvalue*mat = diag where diag is a diagonal matrix) 



 stdgens: The LGO standard-generators $\newline$ mat: A monomial matrix (ie $w$) $\newline$ slp: An already existing list of instructions *optional $\newline$ In this function we will transform a monomial matrix $mat \in$ Sp$(d,q)$ into a diagonal matrix diag. Using only the standard-generators $s,u,v$ this will lead to a monomial matrix tmpvalue and $tmpvalue^{-1} \cdot diag = mat$ (i.e. diag = tmpvalue*mat ). Furthermore we will return list slp of
instructions which will (when evaluated at the LGO standard-generators) yields
diag. }

 

\subsection{\textcolor{Chapter }{DiagSLPSp}}
\logpage{[ 5, 2, 6 ]}\nobreak
\hyperdef{L}{X7F37F4B28245472E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagSLPSp({\mdseries\slshape stdgens, diag, slp})\index{DiagSLPSp@\texttt{DiagSLPSp}}
\label{DiagSLPSp}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp (A list of instructions to evaluate diag if slp was Input then this
instructions are added to slp) 



 stdgens: The LGO standard-generators $\newline$ diag: A diagonal matrix (eg diag) $\newline$ slp: An already existing list of instructions *optional $\newline$ Writes a list of instructions which evaluated with LGO standard-generators
yield the diagonal matrix of the input. }

 

\subsection{\textcolor{Chapter }{BruhatDecompositionSp}}
\logpage{[ 5, 2, 7 ]}\nobreak
\hyperdef{L}{X7EABBF4F7A4DBF8A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BruhatDecompositionSp({\mdseries\slshape stdgens, g})\index{BruhatDecompositionSp@\texttt{BruhatDecompositionSp}}
\label{BruhatDecompositionSp}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
pgr (A SLP to compute $u_1,u_2,p_{sign}$ and $diag$ and the matrices $u_1, u_2, p_{sign}$ and $diag$ itself.) 



 stdgens: The LGO standard-generators $ \newline $ g: A matrix in Sp$(d,q)$ $ \newline $ Uses \texttt{UnitriangularDecompositionSp()}, \texttt{MonomialSLPSp()} and \texttt{DiagSLPSp()} to write a matrix $g \in$ Sp$(d,q)$ as $g = u_1^{-1} \cdot p_{sign} \cdot diag \cdot u_2^{-1}$ where $u_1,u_2$ are lower unitriangular matrices, $p_{sign}$ is a monomial matrix and $diag$ a diagonal matrix. It furthermore yields an SLP that returns the above
matrices if evaluated with the LGO standard-generators. }

 }

 }

 \def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\immediate\write\pagenrlog{["Ind", 0, 0], \arabic{page},}
\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
