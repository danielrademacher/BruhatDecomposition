% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage[top=37mm,bottom=37mm,left=27mm,right=27mm]{geometry}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{Bruhat Decomposition\mbox{}}}\\
\vfill

\hypersetup{pdftitle=Bruhat Decomposition}
\markright{\scriptsize \mbox{}\hfill Bruhat Decomposition \hfill\mbox{}}
{\Huge \textbf{Straight-line programs with memory and matrix Bruhat decomposition\mbox{}}}\\
\vfill

{January 2019\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{Alice Niemeyer  \mbox{}}}\\
{\Large \textbf{Dominik Bernhardt  \mbox{}}}\\
{\Large \textbf{Daniel Rademacher  \mbox{}}}\\
{\Large \textbf{ Christian Singendonk  \mbox{}}}\\
\hypersetup{pdfauthor=Alice Niemeyer  ; Dominik Bernhardt  ; Daniel Rademacher  ;  Christian Singendonk  }
\mbox{}\\[2cm]
\begin{minipage}{12cm}\noindent
 This implementation follows the ideas of "Straight-line programs with memory
and matrix Bruhat decomposition" by Alice Niemeyer, Tomasz Popiel and Cheryl
Praeger. \end{minipage}

\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{Alice Niemeyer  }  Email: \href{mailto://alice.niemeyer@mathb.rwth-aachen.de} {\texttt{alice.niemeyer@mathb.rwth-aachen.de}}}\\
{\mbox{}\\
\small \noindent \textbf{Dominik Bernhardt  }  Email: \href{mailto://bernhardt@mathb.rwth-aachen.de} {\texttt{bernhardt@mathb.rwth-aachen.de}}}\\
{\mbox{}\\
\small \noindent \textbf{Daniel Rademacher  }  Email: \href{mailto://daniel.rademacher@rwth-aachen.de} {\texttt{daniel.rademacher@rwth-aachen.de}}}\\
{\mbox{}\\
\small \noindent \textbf{ Christian Singendonk  }  Email: \href{mailto://christian.singendonk@rwth-aachen.de} {\texttt{christian.singendonk@rwth-aachen.de}}}\\

\noindent \textbf{Address: }\begin{minipage}[t]{8cm}\noindent
 Lehrstuhl B f{\"u}r Mathematik\\
 Pontdriesch 14/16\\
 52062 Aachen\\
 (Germany) \end{minipage}
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
{\copyright} 2019 by Alice Niemeyer, Dominik Bernhardt, Christian Singendonk
and Daniel Rademacher \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 2 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Foreword}}\label{Foreword}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X8248CBC383A4431E}{}
{
 Let $G$ be the SL, SU, Sp or SO. Let g be an element in G. We want to write $g = u_1 \cdot w \cdot u_2$ with $u_1$ and $u_2$ lower unitriangular matrices and $w$ a monomial matrix. 

 This is already implemented for: 
\begin{itemize}
\item  Special linear group (SL) [\ref{BDSL}] 
\item  Special unitary group (SU) [\ref{BDSU}] 
\item  Symplectic group (Sp) [\ref{BDSp}] 
\end{itemize}
 }

 
\chapter{\textcolor{Chapter }{Bruhat Decomposition for the special linear group (SL)}}\label{BDSL}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7ED5154B7CE8175E}{}
{
 This implementation follows the ideas of "Straight-line programs with memory
and matrix Bruhat decomposition" by Alice Niemeyer, Tomasz Popiel and Cheryl
Praeger.

 Let $g \in SL(d,p^f)$. The Bruhat Decomposition computes $g = u_1 \cdot w \cdot u_2$, where 
\begin{itemize}
\item  $u_1,u_2$ are lower unitriangular matrices

 
\item  $w$ is monomial matrix

 
\end{itemize}
 In this algorithm we want to compute the Bruhat-Decomposition of $g$ and give $g$ (respectively $u_1,w$ and $u_2$) as word in the "LGO standard generators". This generators can be found in
"Constructive Recognition of Classical Groups in odd characteristic" by C. R.
Leedham-Green and E. A. O{\textquoteright}Brien. \cite[Chapter 3.1]{CR1} 
\begin{itemize}
\item  1) While computing $u_1$ (resp $u_2$) with some kind of Gau{\ss}-Algorithm, we express the matrices as product of
transvections. For $ 1 \leq j \leq \neq i \leq d: t_{i,j}(\alpha) $ is the matrix $T$ with 1-entries on diagonal, $T_{i,j} = \alpha$, 0 elsewhere. Each $t_{i,j}(\alpha)$ can be computed from $t_{2,1}(\alpha)$ via recursion, where we have to distinguish the odd and even dimensons \cite[Lemma 4.2]{CR1}. This again can be expressed as a product of $t_{2,1}(\omega^{ell})$ (where $\omega$ is a primitive element and $0 \leq ell \leq \neq f$). The transvections as words in the standard generators are described in \cite[Lemma 4.2]{CR1}. This yields a decomposition of $u_1$ and $u_2$ in standard generators.
\item 2) In a further step we will decompose the monomial Matrix $w$ in a "product of permutations" and a diagonal Matrix. ( How to associate this
product of permutations with a product of generators is further described in
"Implemented Subfunctions (Part I)" [\ref{FirstSect}] and "Decomposing the Monomial Matrix (Part III)" [\ref{FourthSect}] ). 
\item 3) The last step is the decomposition of the diagonal Matrix in 2) as a word
in the standard generators.
\end{itemize}
 We won't do this matrix multiplications directly, but write them in a list to
evaluate in a StraightLineProgram. \cite[Section 2]{CR1} Although described differently in the paper, we sometimes will allow
instructions to multiply more than two elements (eg during conjugating). This
doesn't affect the optimality of an SLP much, but higly increases the
readability of our implementation.

 \label{ThreeBack} 
\section{\textcolor{Chapter }{Implemented Subfunctions (Part I)}}\label{FirstSect}
\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X81E72B8282AC6ED6}{}
{
 Later we will need some additional functions. Why they are needed and where
they are needed is described here. 

 
\begin{itemize}
\item  \texttt{MakeSLP()}: After the \texttt{BruhatDecomposition()} we get a list of instructions to calculate the matrices we want using the LGO
standard generators. \texttt{MakeSLP()} is used to get a SLP out of these instructions.
\item  \texttt{CoefficientsPrimitiveElement()}: It expresses an element w in a field fld as a linear combination of a
Primitive Element. This is important for the transvections. \cite[Lemma 4.2]{CR1}
\item  \texttt{MyPermutationMat()}: Turns a permutation into a permutation matrix. We need it to calculate the
LGO standard generator. 
\item  \texttt{LGOStandardGens()}: This function computes the standard generators of SL as given by C. R.
Leedham-Green and E. A. O'Brien in "Constructive Recognition of Classical
Groups in odd characteristic". \cite[Chapter 3.1]{CR1} 

 
\item  \texttt{HighestSlotOfSLP()}: The following function determines the highest slot of a SLP constructed from
the list slp will write in. This is important to glue SLPs together. 
\item  \texttt{MatToWreathProd()} and \texttt{WreathProdToMat()}: In \texttt{PermSLP()} [\ref{PermSLP}] we want to transform the monomial matrix $w$ given by \texttt{UnipotentDecomposition()} into a diagonal matrix. (The exact procedure is described in \texttt{PermSLP()} [\ref{PermSLP}])

 Since multiplying the LGO standard-generators $s,v$ and $x$ not only involves permutations but we also have to consider which non-zero
entries are $+1$ and which $-1$, we want to associate this matrices with permutations on $2d$ points. (cf. Wreath-Product)

 $[s,v,x] \to Sym(2d), M \to $ \texttt{Mwr} where $i^{Mwr} = j$ and $(i+d)^{Mwr}= j+d$ if $ M_{i,j} = 1$ and $i^{Mwr} = j+d$ and $(i+d)^{Mwr}= j$ if $M_{i,j} = -1$ for $1 \leq i \leq d$.

 Due to their relation to wreath-products, we will call denote the image of a
matrix \texttt{M}$ \in [s,v,x] $ by \texttt{Mwr}. 

 In fact the association from \texttt{MatToWreathProd()} [\ref{MatToWreathProd}] is an isomorphism and we can associate to each permutation we compute during \texttt{PermSLP()} [\ref{PermSLP}] a signed permutation matrix (a monomial matrix with only $+1$ and $-1$ as non-zero entries). 

 $M_{i,j} = 1$ if $i^{Mwr} = j \leq d$ and $M_{i,j} = -1$ if $i^{Mwr} = j+d$ 
\item  \texttt{AEM()}: Write instructions for Ancient Egyptian Multiplication in slp. At several
occasions we will need to compute a high power of some value saved in a memory
slot.
\item  \texttt{TestIfMonomial()}: Tests if a given matrix M is monomial matrix. We use it to decide whether we
are already finished in \texttt{UnipotentDecomposition()}.
\end{itemize}
 For some functions also exist a NC version. See [\ref{SixtSect}]. }

 
\section{\textcolor{Chapter }{UnipotentDecomposition (Part II - a)}}\label{ThirdSect}
\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X83E0C06C7AB80DD4}{}
{
 In this section is the \texttt{UnipotentDecomposition()} described. This method is used to compute the Unitriangular decomposition of
the matrix $g$. [\ref{UnipotentDecomposition}] 

 For this we use five local functions in the \texttt{UnipotentDecomposition()}. They are \texttt{TransvecAtAlpha()}, \texttt{ShiftTransvections()}, \texttt{FastShiftTransvections()}, \texttt{BackShiftTransvections()} and \texttt{FastBackShiftTransvections()}. For further information to these functions look at [\ref{Local}]. 

 The difference to \texttt{UnipotentDecompositionWithTi()} [\ref{ThirdSect2}] is that this version won't store all the transvections $t_{i,i-1}(\omega^l)$. This will increase the runtime but reduce the memory usage by $(d-3) \cdot f$ compared to the \texttt{UnipotentDecompositionWithTi()}.

 The function can be called for example by 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@d := 3;;|
  !gapprompt@gap>| !gapinput@q := 5;;|
  !gapprompt@gap>| !gapinput@L := SL(d, q);;|
  !gapprompt@gap>| !gapinput@m := PseudoRandom(L);;|
  !gapprompt@gap>| !gapinput@stdgens := LGOStandardGens(d, q);;|
  !gapprompt@gap>| !gapinput@UnipotentDecomposition( stdgens, g);;|
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{UnipotentDecomposition saving Transvections (Part II - b)}}\label{ThirdSect2}
\logpage{[ 2, 3, 0 ]}
\hyperdef{L}{X8119AABE86F3606D}{}
{
 In this section is the \texttt{UnipotentDecompositionWithTi()} described. This method is used to compute the Unitriangular decomposition of
the matrix $g$. [\ref{UnipotentDecompositionWithTi}] 

 In this version we will store all the transvections $t_{i,i-1}(\omega^l)$. This will increase the memory usage by $(d-3) \cdot f$ but reduce runtime.

 In \texttt{UnipotentDecompositionWithTi()} we use two local functions. They are \texttt{TransvectionAtAlpha()} and \texttt{ComputeAllTransvections()}. For further information to these functions look at [\ref{LocalWithTi}]. 

 The function can be called for example by 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@d := 3;;|
  !gapprompt@gap>| !gapinput@q := 5;;|
  !gapprompt@gap>| !gapinput@L := SL(d, q);;|
  !gapprompt@gap>| !gapinput@m := PseudoRandom(L);;|
  !gapprompt@gap>| !gapinput@stdgens := LGOStandardGens(d, q);;|
  !gapprompt@gap>| !gapinput@UnipotentDecompositionWithTi( stdgens, g);;|
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Decomposing the Monomial Matrix (Part III)}}\label{FourthSect}
\logpage{[ 2, 4, 0 ]}
\hyperdef{L}{X80C69E33879354C8}{}
{
 We use three functions to decompose the monomial matrix $w$ we get from \texttt{UnipotentDecomposition()}. They are: 
\begin{itemize}
\item  \texttt{PermutationMonomialMatrix()}: Find the permutation (in Sym(d) corresponding to the monomial matrix $w$) and $diag$ a diagonal matrix, where $diag[i]$ is the non-zero entry of row $i$. [\ref{PermutationMonomialMatrix}] 
\item  \texttt{PermSLP()}: In this function we will transform a monomial matrix $w \in $SL$(d,q)$ into a diagonal matrix $diag$. Using only the standard-generators $s,v,x$. This will lead to a monomial matrix $p_{sign}$ with only $\pm 1$ in non-zero entries and $p_{sign} \cdot diag = w$ (i.e. $diag = (p_{sign})^{-1} \cdot w$ ).

 Furthermore we will return list \texttt{slp} of instructions which will (when evaluated at the LGO standard-generators)
yield $diag$. It is sufficient for $diag$ to be diagonal, if the permutation associated with $w$ (i.e. $i^{\pi_w} = j$ if $M_{i,j} \neq 0$) is the inverse of the permutation associated to $p_{sign}$ (again only to Sym($d$) ).

 In \texttt{PermSLP()} we thus transform $\pi_w$ to $()$ using only $\{ \pi_s, \pi_v, \pi_x \}$. In order to know $diag$ without computing all matrix multiplications, (we don't know the signs of $p_{sign}$), we compute a second permutation simultaneously (here using their
identification with permutations in Sym$(2d)$ and identifying $\{ \pi_s, \pi_v, \pi_x \}$ with $\{s,v,x\}$ ). [\ref{PermSLP}] 
\item  \texttt{DiagonalDecomposition()}: Writes a list of instructions which evaluated on LGO standard-generators
yield the diagonal matrix of the input. [\ref{DiagonalDecomposition}]
\end{itemize}
 To these three functions is also a NC version implemented. See [\ref{SixtSect}]. }

 
\section{\textcolor{Chapter }{Main Function (Part IV)}}\label{FifthSect}
\logpage{[ 2, 5, 0 ]}
\hyperdef{L}{X7D8EB03B8022F892}{}
{
 In \texttt{BruhatDecomposition()} [\ref{BruhatDecomposition}] we put everything together. We use the three functions \texttt{UnipotentDecomposition()} [\ref{UnipotentDecomposition}], \texttt{PermSLP()} [\ref{PermSLP}] and \texttt{DiagonalDecomposition()} [\ref{DiagonalDecomposition}] to compute matrices with $u_1^{-1} \cdot p_{sign} \cdot diag \cdot u_2^{-1} = g$ and a SLP \texttt{pgr} that computes these matrices with the LGO standard generators.

 Here is an exampel: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@mat := [ [ Z(5)^2, Z(5)^0, Z(5)^2 ],|
  !gapprompt@>| !gapinput@            [ Z(5)^3, 0*Z(5), 0*Z(5) ],|
  !gapprompt@>| !gapinput@            [ 0*Z(5), Z(5)^2, Z(5)^2 ] ];;|
  !gapprompt@gap>| !gapinput@L := BruhatDecomposition(LGOStandardGens(3,5), mat);|
  !gapprompt@gap>| !gapinput@result := ResultOfStraightLineProgram(L[1], LGOStandardGens(3,5));|
\end{Verbatim}
 \texttt{BruhatDecompositionWithTi()} [\ref{BruhatDecompositionWithTi}] works like \texttt{BruhatDecomposition()} [\ref{BruhatDecomposition}] but uses \texttt{UnipotentDecompositionWithTi()} [\ref{UnipotentDecompositionWithTi}] instead of \texttt{UnipotentDecomposition()} [\ref{UnipotentDecomposition}]. 

 You can use it in the same way like \texttt{BruhatDecomposition()}: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@mat := [ [ Z(5)^2, Z(5)^0, Z(5)^2 ],|
  !gapprompt@>| !gapinput@            [ Z(5)^3, 0*Z(5), 0*Z(5) ],|
  !gapprompt@>| !gapinput@            [ 0*Z(5), Z(5)^2, Z(5)^2 ] ];;|
  !gapprompt@gap>| !gapinput@L := BruhatDecompositionWithTi(LGOStandardGens(3,5), mat);|
  !gapprompt@gap>| !gapinput@result := ResultOfStraightLineProgram(L[1], LGOStandardGens(3,5));|
\end{Verbatim}
 To both functions is also a NC version implemented. See [\ref{SixtSect}]. }

 
\section{\textcolor{Chapter }{NC Version}}\label{SixtSect}
\logpage{[ 2, 6, 0 ]}
\hyperdef{L}{X864D6CAB7CE3BBF0}{}
{
 Here is the NC version of the Bruhat Decomposition described. In all
implemented functions are all used functions replaced through their NC version
(if one exists). Moreover are all checks from functions of
MyBruhatDecomposition removed.

 These functions has been modified by this actions and got a NC Version: 
\begin{itemize}
\item \texttt{MakeSLP()}[\ref{MakeSLP}] $\to$ \texttt{MakeSLPNC()}[\ref{MakeSLPNC}] (uses the NC version of \texttt{StraightLineProgram})
\item \texttt{MyPermutationMat()} [\ref{MyPermutationMat}] $\to$ \texttt{MyPermutationMatNC()} [\ref{MyPermutationMatNC}] (uses the NC version of \texttt{ConvertToMatrixRep})
\item \texttt{LGOStandardGens()} [\ref{LGOStandardGens}] $\to$ \texttt{LGOStandardGensNC()} [\ref{LGOStandardGensNC}] (uses the NC version of \texttt{MyPermutationMat()})
\item \texttt{MatToWreathProd()} [\ref{MatToWreathProd}] $\to$ \texttt{MatToWreathProdNC()} [\ref{MatToWreathProdNC}] (no checks for user input)
\item \texttt{TestIfMonomial()} [\ref{TestIfMonomial}] $\to$ \texttt{TestIfMonomialNC()} [\ref{TestIfMonomialNC}] (no checks for user input)
\item \texttt{UnipotentDecomposition()} [\ref{UnipotentDecomposition}] $\to$ \texttt{UnipotentDecompositionNC()} [\ref{UnipotentDecompositionNC}] (no checks for user input)
\item \texttt{UnipotentDecompositionWithTi()} [\ref{UnipotentDecompositionWithTi}] $\to$ \texttt{UnipotentDecompositionWithTiNC()} [\ref{UnipotentDecompositionWithTiNC}] (no checks for user input)
\item \texttt{PermutationMonomialMatrix()} [\ref{PermutationMonomialMatrix}] $\to$ \texttt{PermutationMonomialMatrixNC()} [\ref{PermutationMonomialMatrixNC}] (no checks for user input)
\item \texttt{PermSLP()} [\ref{PermSLP}] $\to$ \texttt{PermSLPNC()} [\ref{PermSLPNC}] (no checks for unser input and uses \texttt{PermutationMonomialMatrixNC()})
\item \texttt{DiagonalDecomposition()} [\ref{DiagonalDecomposition}] $\to$ \texttt{DiagonalDecompositionNC()} [\ref{DiagonalDecompositionNC}] (no checks for user input)
\item \texttt{BruhatDecomposition()} [\ref{BruhatDecomposition}] $\to$ \texttt{BruhatDecompositionNC()} [\ref{BruhatDecompositionNC}] (uses \texttt{UnipotentDecompositionNC()}, \texttt{PermSLPNC()} and \texttt{DiagonalDecompositionNC})
\item \texttt{BruhatDecompositionWithTi()} [\ref{BruhatDecompositionWithTi}] $\to$ \texttt{BruhatDecompositionWithTiNC()} [\ref{BruhatDecompositionWithTiNC}] (uses \texttt{UnipotentDecompositionWithTiNC()}, \texttt{PermSLPNC()} and \texttt{DiagonalDecompositionNC()})
\end{itemize}
 }

 
\section{\textcolor{Chapter }{Functions}}\logpage{[ 2, 7, 0 ]}
\hyperdef{L}{X86FA580F8055B274}{}
{
 \label{Functions} 

\subsection{\textcolor{Chapter }{MakeSLP}}
\logpage{[ 2, 7, 1 ]}\nobreak
\hyperdef{L}{X7AFC8C7D78152151}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MakeSLP({\mdseries\slshape slp, genlen})\index{MakeSLP@\texttt{MakeSLP}}
\label{MakeSLP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
An SLP using the instructions of slp and genlen inputs



 Input: 
\begin{itemize}
\item  \texttt{slp}: A list of instructions for a straight-line program 
\item  \texttt{genlen}: The number of inputs for our SLP (ie the number of generators ) 
\end{itemize}
 Uses \texttt{StraightLineProgram} to make an SLP out of the instructions from slp and dependent on genlen. }

 

\subsection{\textcolor{Chapter }{MakeSLPNC}}
\logpage{[ 2, 7, 2 ]}\nobreak
\hyperdef{L}{X81E533548403C575}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MakeSLPNC({\mdseries\slshape slp, genlen})\index{MakeSLPNC@\texttt{MakeSLPNC}}
\label{MakeSLPNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
An SLP using the instructions of slp and genlen inputs



 This function works like \texttt{MakeSLP()} [\ref{MakeSLP}] but uses \texttt{StraightLineProgramNC} instead of \texttt{StraightLineProgram}. }

 

\subsection{\textcolor{Chapter }{CoefficientsPrimitiveElement}}
\logpage{[ 2, 7, 3 ]}\nobreak
\hyperdef{L}{X828EE9DF7B60A03E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CoefficientsPrimitiveElement({\mdseries\slshape fld, alpha})\index{CoefficientsPrimitiveElement@\texttt{CoefficientsPrimitiveElement}}
\label{CoefficientsPrimitiveElement}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A vector $c$ such that for $\omega$ primitive element in \texttt{fld} is $ \sum c[i] \omega^{(i-1)} = $\texttt{alpha}



 Input: 
\begin{itemize}
\item  \texttt{fld}: A field 
\item  \texttt{alpha} : An element of \texttt{fld} 
\end{itemize}
 The function has been written by Thomas Breuer. It expresses an element w in a
field fld as a linear combination of a Primitive Element. }

 

\subsection{\textcolor{Chapter }{MyPermutationMat}}
\logpage{[ 2, 7, 4 ]}\nobreak
\hyperdef{L}{X7B138D977A8B7189}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MyPermutationMat({\mdseries\slshape perm, dim, fld})\index{MyPermutationMat@\texttt{MyPermutationMat}}
\label{MyPermutationMat}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
The permutation matrix $res \in fld^{dim \times dim}$ of \texttt{perm} (i.e. $res_{i,j} = 1_{fld}$ if $i^{perm} = j$).



 Input: 
\begin{itemize}
\item  \texttt{perm}: A permutation 
\item  \texttt{dim} : A natural number 
\item  \texttt{fld} : A field 
\end{itemize}
 Given a permutation \texttt{perm}, an integer \texttt{dim}$ > 0$ and a field \texttt{fld}, this function computes the permutation matrix $res \in fld^{dim \times dim}$. }

 

\subsection{\textcolor{Chapter }{MyPermutationMatNC}}
\logpage{[ 2, 7, 5 ]}\nobreak
\hyperdef{L}{X8786DC8B80BDB30E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MyPermutationMatNC({\mdseries\slshape perm, dim, fld})\index{MyPermutationMatNC@\texttt{MyPermutationMatNC}}
\label{MyPermutationMatNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
The permutation matrix $res \in fld^{dim \times dim}$ of \texttt{perm} (i.e. $res_{i,j} = 1_{fld}$ if $i^{perm} = j$).



 This function works like \texttt{MyPermutationMat()} [\ref{MyPermutationMat}] but uses \texttt{ConvertToMatrixRepNC} instead of \texttt{ConvertToMatrixRep}. }

 

\subsection{\textcolor{Chapter }{LGOStandardGens}}
\logpage{[ 2, 7, 6 ]}\nobreak
\hyperdef{L}{X7C8ABD7D8634C91E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LGOStandardGens({\mdseries\slshape d, q})\index{LGOStandardGens@\texttt{LGOStandardGens}}
\label{LGOStandardGens}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{stdgens} the LGO standard-generators of $SL(d,q)$.



 Input: 
\begin{itemize}
\item  \texttt{d}: the dimension of our matrix 
\item  \texttt{q}: A prime power $q = p^f$, where $F_q$ ist the field whereover the matrices are defined 
\end{itemize}
 This function computes the standard generators of SL as given by C. R.
Leedham-Green and E. A. O'Brien in "Constructive Recognition of Classical
Groups in odd characteristic". \cite{CR2} \cite[Chapter 3.1]{CR1} }

 

\subsection{\textcolor{Chapter }{LGOStandardGensNC}}
\logpage{[ 2, 7, 7 ]}\nobreak
\hyperdef{L}{X855BEE5C7B364988}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LGOStandardGensNC({\mdseries\slshape d, q})\index{LGOStandardGensNC@\texttt{LGOStandardGensNC}}
\label{LGOStandardGensNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{stdgens} the LGO standard-generators of $SL(d,q)$.



 Input: 
\begin{itemize}
\item  \texttt{d}: the dimension of our matrix 
\item  \texttt{q}: A prime power $q = p^f$, where $F_q$ ist the field whereover the matrices are defined 
\end{itemize}
 This function works like \texttt{LGOStandardGens()} [\ref{LGOStandardGens}] but uses \texttt{MyPermutationMatNC()} instead of \texttt{MyPermutationMat()}. }

 

\subsection{\textcolor{Chapter }{HighestSlotOfSLP}}
\logpage{[ 2, 7, 8 ]}\nobreak
\hyperdef{L}{X7E4A850D7AAC4293}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{HighestSlotOfSLP({\mdseries\slshape slp})\index{HighestSlotOfSLP@\texttt{HighestSlotOfSLP}}
\label{HighestSlotOfSLP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{highestslot} the number of slots the SLP \texttt{slp} will need if evaluated.



 Input: 
\begin{itemize}
\item  \texttt{slp}: A list of instructions satisfying the properties for an SLP 
\end{itemize}
 The function determines the highest slot a SLP constructed from the list slp
will write in. }

 

\subsection{\textcolor{Chapter }{MatToWreathProd}}
\logpage{[ 2, 7, 9 ]}\nobreak
\hyperdef{L}{X7D23BD4E79542F4B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MatToWreathProd({\mdseries\slshape M})\index{MatToWreathProd@\texttt{MatToWreathProd}}
\label{MatToWreathProd}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{perm}: the permutation \texttt{Mwr} (see Describtion)



 Input: 
\begin{itemize}
\item  \texttt{M}: A signed permutation matrix. 
\end{itemize}
 In \texttt{PermSLP()} [\ref{PermSLP}] we want to transform the monomial matrix $w$ given by \texttt{UnipotentDecomposition()} into a diagonal matrix. (The exact procedure is described in \texttt{PermSLP()} [\ref{PermSLP}])

 Since multiplying the LGO standard-generators $s,v$ and $x$ not only involves permutations but we also have to consider which non-zero
entries are $+1$ and which $-1$, we want to associate this matrices with permutations on $2d$ points. (cf. Wreath-Product)

 $[s,v,x] \to Sym(2d), M \to $ \texttt{Mwr} where $i^{Mwr} = j$ and $(i+d)^{Mwr}= j+d$ if $ M_{i,j} = 1$ and $i^{Mwr} = j+d$ and $(i+d)^{Mwr}= j$ if $M_{i,j} = -1$ for $1 \leq i \leq d$.

 Due to their relation to wreath-products, we will call denote the image of a
matrix \texttt{M}$ \in [s,v,x] $ by \texttt{Mwr}. }

 

\subsection{\textcolor{Chapter }{MatToWreathProdNC}}
\logpage{[ 2, 7, 10 ]}\nobreak
\hyperdef{L}{X7E91E7098456AFDD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MatToWreathProdNC({\mdseries\slshape M})\index{MatToWreathProdNC@\texttt{MatToWreathProdNC}}
\label{MatToWreathProdNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{perm}: the permutation \texttt{Mwr} (see Describtion)



 Input: 
\begin{itemize}
\item  \texttt{M}: signed permutation matrix. 
\end{itemize}
 This function works like \texttt{MatToWreathProd()} [\ref{MatToWreathProd}] but doesn't check the user input. }

 

\subsection{\textcolor{Chapter }{WreathProdToMat}}
\logpage{[ 2, 7, 11 ]}\nobreak
\hyperdef{L}{X87F98DEC85E3FDAA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{WreathProdToMat({\mdseries\slshape perm, dim, fld})\index{WreathProdToMat@\texttt{WreathProdToMat}}
\label{WreathProdToMat}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{res}: The Matrix \texttt{M} satisfying the properties from the description.



 Input: 
\begin{itemize}
\item  \texttt{perm}: A permutation in Sym$(2d)$ sth. $\{ \{i,i+d \}\}: 1 \leq i \leq d$ are blocks 
\item  \texttt{dim}: The dimension of the matrix we want perm send to 
\item  \texttt{fld}: The field whereover the matrix is defined 
\end{itemize}
 In fact the association from \texttt{MatToWreathProd()} [\ref{MatToWreathProd}] is an isomorphism and we can associate to each permutation we compute during \texttt{PermSLP()} [\ref{PermSLP}] a signed permutation matrix. $M_{i,j} = 1$ if $i^{Mwr} = j \leq d$ and $M_{i,j} = -1$ if $i^{Mwr} = j+d$ }

 

\subsection{\textcolor{Chapter }{AEM}}
\logpage{[ 2, 7, 12 ]}\nobreak
\hyperdef{L}{X7F52B1487F587A1C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{AEM({\mdseries\slshape spos, respos, tmppos, k})\index{AEM@\texttt{AEM}}
\label{AEM}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{instr}: Lines of an SLP that will (when evaluated) take the value $b$ saved in \texttt{spos} and write $b^k$ in \texttt{respos}



 Input: 
\begin{itemize}
\item  \texttt{spos}: The memory slot, where a value b is saved in. 
\item  \texttt{respos}: The memory slot we want the exponentation to be written in. 
\item  \texttt{tmppos}: A memory slot for temporary results. 
\item  \texttt{k}: An integer. 
\end{itemize}
 At several occasions we will need to compute a high power of some value saved
in a memory slot. For this purpose this function is a variaton of AEM (Ancient
Egytian Multiplication).

 Remark: \texttt{tmpos} and \texttt{respos} must differ. If \texttt{spos} = \texttt{respos} or \texttt{spos} = \texttt{tmpos} it will be overwritten. }

 

\subsection{\textcolor{Chapter }{TestIfMonomial}}
\logpage{[ 2, 7, 13 ]}\nobreak
\hyperdef{L}{X7C7736A682A7A0D5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{TestIfMonomial({\mdseries\slshape M})\index{TestIfMonomial@\texttt{TestIfMonomial}}
\label{TestIfMonomial}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true if \texttt{M} is Monomial, false else.



 Input: 
\begin{itemize}
\item  \texttt{M}: A matrix. 
\end{itemize}
 Tests if a given matrix \texttt{M} is a monomial matrix. There is a function in GAP, however it does not seem to
work for SL$(d,q)$. }

 

\subsection{\textcolor{Chapter }{TestIfMonomialNC}}
\logpage{[ 2, 7, 14 ]}\nobreak
\hyperdef{L}{X82F86D858626598B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{TestIfMonomialNC({\mdseries\slshape M})\index{TestIfMonomialNC@\texttt{TestIfMonomialNC}}
\label{TestIfMonomialNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true if \texttt{M} is Monomial, false else.



 Input: 
\begin{itemize}
\item  \texttt{M}: A matrix. 
\end{itemize}
 This function works like \texttt{TestIfMonomial()} [\ref{TestIfMonomial}] but doesn't check the user input. }

 

\subsection{\textcolor{Chapter }{Transvections2}}
\logpage{[ 2, 7, 15 ]}\nobreak
\hyperdef{L}{X85C18012862F6FAD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Transvections2({\mdseries\slshape stdgens, omega, slp, pos})\index{Transvections2@\texttt{Transvections2}}
\label{Transvections2}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp: The list of instruction with additional instructions writing $t_{2,1}(\omega^{ell})$ in Slot $pos[ell+1]$ f{\"u}r $ 0 \leq ell \leq \neq f$.



 Input: 
\begin{itemize}
\item  \texttt{stdgens}: The LGO standard-generators of SL$(d,q)$. 
\item  \texttt{omega}: A primitive element of $GF(q)$. 
\item  \texttt{slp}: A list of instructions. 
\item  \texttt{pos}: A list of numbers, denoting where to save the transvections $t_{2,1}(\omega^{ell})$ f{\"u}r $0 \leq ell \leq \neq f$. 
\end{itemize}
 Let \texttt{stdgens} be the list of standard generators for SL$(d,p^f)$ and let $\omega$ be a primitive element of $G(p^f)$. This function computes $T_2$ and record what we do in \texttt{slp}.

 This function coincides with \cite[Equation (6), p12]{CR1}. }

 

\subsection{\textcolor{Chapter }{UnipotentDecomposition}}
\logpage{[ 2, 7, 16 ]}\nobreak
\hyperdef{L}{X8779E9377C892EB9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnipotentDecomposition({\mdseries\slshape arg})\index{UnipotentDecomposition@\texttt{UnipotentDecomposition}}
\label{UnipotentDecomposition}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{slp}: A list of instructions yielding $u_1,u_2$ if evaluated as SLP, $[u_1,g,u_2]$ (the matrices of the Bruhat-Decomposition).



 Input: 
\begin{itemize}
\item  \texttt{stdgens}: The LGO standard-generators. 
\item  \texttt{g}: A matrix in SL$(d,q)$. 
\end{itemize}
 Computes the Unitriangular decomposition of the matrix $g$. }

 

\subsection{\textcolor{Chapter }{UnipotentDecompositionNC}}
\logpage{[ 2, 7, 17 ]}\nobreak
\hyperdef{L}{X826BD2C9824513AC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnipotentDecompositionNC({\mdseries\slshape arg})\index{UnipotentDecompositionNC@\texttt{UnipotentDecompositionNC}}
\label{UnipotentDecompositionNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{slp}: A list of instructions yielding $u_1,u_2$ if evaluated as SLP, $[u_1,g,u_2]$ (the matrices of the Bruhat-Decomposition).



 This function works like \texttt{UnipotentDecomposition()} [\ref{UnipotentDecomposition}] but doesn't check the user input. }

 

\subsection{\textcolor{Chapter }{UnipotentDecompositionWithTi}}
\logpage{[ 2, 7, 18 ]}\nobreak
\hyperdef{L}{X7D30168E7F1DE65C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnipotentDecompositionWithTi({\mdseries\slshape arg})\index{UnipotentDecompositionWithTi@\texttt{UnipotentDecompositionWithTi}}
\label{UnipotentDecompositionWithTi}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{slp}: A list of instructions yielding $u_1,u_2$ if evaluated as SLP, $[u_1,g,u_2]$ (the matrices of the Bruhat-Decomposition).



 Input: 
\begin{itemize}
\item  \texttt{stdgens}: The LGO standard-generators. 
\item  \texttt{g}: A matrix in SL$(d,q)$. 
\end{itemize}
 Compute the Bruhat decomposition of the matrix \texttt{g}, given the standard generators for the group.

 In this version we will store all the transvections $T_{i,i-1}(\omega^l)$. This will increase the memory usage by $(d-3) \cdot f$ but reduce runtime. }

 

\subsection{\textcolor{Chapter }{UnipotentDecompositionWithTiNC}}
\logpage{[ 2, 7, 19 ]}\nobreak
\hyperdef{L}{X819FFEC886196D19}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnipotentDecompositionWithTiNC({\mdseries\slshape arg})\index{UnipotentDecompositionWithTiNC@\texttt{UnipotentDecompositionWithTiNC}}
\label{UnipotentDecompositionWithTiNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{slp}: A list of instructions yielding $u_1,u_2$ if evaluated as SLP, $[u_1,g,u_2]$ (the matrices of the Bruhat-Decomposition).



 Input: 
\begin{itemize}
\item  \texttt{stdgens}: The LGO standard-generators. 
\item  \texttt{g}: A matrix in SL$(d,q)$. 
\end{itemize}
 This function works like \texttt{UnipotentDecompositionWithTi()} [\ref{UnipotentDecompositionWithTi}] but doesn't check the user input. }

 

\subsection{\textcolor{Chapter }{PermutationMonomialMatrix}}
\logpage{[ 2, 7, 20 ]}\nobreak
\hyperdef{L}{X7A75AB0D8104691A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PermutationMonomialMatrix({\mdseries\slshape M})\index{PermutationMonomialMatrix@\texttt{PermutationMonomialMatrix}}
\label{PermutationMonomialMatrix}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 
\begin{itemize}
\item  \texttt{diag}: The vector of non-zero entries where diag[i] is the non-zero entry of row i. 
\item  \texttt{perm}: The permutation associated to \texttt{M} (ie $i^{perm} = j$ if $M_{i,j} \neq 0$). 
\end{itemize}
 



 Input: 
\begin{itemize}
\item  \texttt{M}: A monomial Matrix
\end{itemize}
 Find the permutation (in Sym$(d)$ corresponding to the monomial matrix \texttt{M}). }

 

\subsection{\textcolor{Chapter }{PermutationMonomialMatrixNC}}
\logpage{[ 2, 7, 21 ]}\nobreak
\hyperdef{L}{X857AAC587E8A7891}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PermutationMonomialMatrixNC({\mdseries\slshape M})\index{PermutationMonomialMatrixNC@\texttt{PermutationMonomialMatrixNC}}
\label{PermutationMonomialMatrixNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 
\begin{itemize}
\item  \texttt{diag}: The vector of non-zero entries where diag[i] is the non-zero entry of row i. 
\item  \texttt{perm}: The permutation associated to \texttt{M} (ie $i^{perm} = j$ if $M_{i,j} \neq 0$). 
\end{itemize}
 



 Input: 
\begin{itemize}
\item  \texttt{M}: A monomial Matrix
\end{itemize}
 This function works like \texttt{PermutationMonomialMatrix()} [\ref{PermutationMonomialMatrix}] but doesn't check the user input. }

 

\subsection{\textcolor{Chapter }{PermSLP}}
\logpage{[ 2, 7, 22 ]}\nobreak
\hyperdef{L}{X79A14A5D8507B0CD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PermSLP({\mdseries\slshape stdgens, mat[, slp]})\index{PermSLP@\texttt{PermSLP}}
\label{PermSLP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 
\begin{itemize}
\item  \texttt{slp}: A list of instructions to evaluate \texttt{p{\textunderscore}sign} (if \texttt{slp} was Input then this instructions are added to \texttt{slp}).
\item  \texttt{p{\textunderscore}sign}: The signed permutation matrix. 
\item  \texttt{mat}: The diagonal matrix \texttt{diag}.
\end{itemize}
 



 Input: 
\begin{itemize}
\item  \texttt{stdgens}: The LGO standard-generators. 
\item  \texttt{mat}: A monomial matrix (i.e. $w$). 
\item  \texttt{slp}: An already existing list of instructions. [optional]
\end{itemize}
 In this function we will transform a monomial matrix $w \in $SL$(d,q)$ into a diagonal matrix $diag$. Using only the standard-generators $s,v,x$. This will lead to a monomial matrix $p_{sign}$ with only $\pm 1$ in non-zero entries and $p_{sign} \cdot diag = w$ (i.e. $diag = (p_{sign})^{-1} \cdot w$ ).

 Furthermore we will return list \texttt{slp} of instructions which will (when evaluated at the LGO standard-generators)
yield $diag$. It is sufficient for $diag$ to be diagonal, if the permutation associated with $w$ (i.e. $i^{\pi_w} = j$ if $M_{i,j} \neq 0$) is the inverse of the permutation associated to $p_{sign}$ (again only to Sym($d$) ).

 In \texttt{PermSLP()} we thus transform $\pi_w$ to $()$ using only $\{ \pi_s, \pi_v, \pi_x \}$. In order to know $diag$ without computing all matrix multiplications, (we don't know the signs of $p_{sign}$), we compute a second permutation simultaneously (here using their
identification with permutations in Sym$(2d)$ and identifying $\{ \pi_s, \pi_v, \pi_x \}$ with $\{s,v,x\}$ ). }

 

\subsection{\textcolor{Chapter }{PermSLPNC}}
\logpage{[ 2, 7, 23 ]}\nobreak
\hyperdef{L}{X7D983C5E791154E9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PermSLPNC({\mdseries\slshape stdgens, mat[, slp]})\index{PermSLPNC@\texttt{PermSLPNC}}
\label{PermSLPNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 
\begin{itemize}
\item  \texttt{slp}: A list of instructions to evaluate \texttt{p{\textunderscore}sign} (if \texttt{slp} was Input then this instructions are added to \texttt{slp}).
\item  \texttt{p{\textunderscore}sign}: The signed permutation matrix. 
\item  \texttt{mat}: The diagonal matrix \texttt{diag}.
\end{itemize}
 



 Input: 
\begin{itemize}
\item  \texttt{stdgens}: The LGO standard-generators. 
\item  \texttt{mat}: A monomial matrix (i.e. $w$). 
\item  \texttt{slp}: An already existing list of instructions. [optional]
\end{itemize}
 This function works like \texttt{PermSLP()} [\ref{PermSLP}] but doesn't check the user input. }

 

\subsection{\textcolor{Chapter }{DiagonalDecomposition}}
\logpage{[ 2, 7, 24 ]}\nobreak
\hyperdef{L}{X85F12FD9859DE12D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagonalDecomposition({\mdseries\slshape stdgens, diam[, slp]})\index{DiagonalDecomposition@\texttt{DiagonalDecomposition}}
\label{DiagonalDecomposition}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 
\begin{itemize}
\item  \texttt{slp}: A list of instructions to evaluate diag (if slp was Input then this
instructions are added to slp). 
\item  \texttt{hres}: The the identity matrix. 
\end{itemize}
 



 Input: 
\begin{itemize}
\item  \texttt{stdgens}: The LGO standard-generators. 
\item  \texttt{diam}: A diagonal matrix (e.g. $diag$). 
\item  \texttt{slp}: An already existing list of instructions. [optional]
\end{itemize}
 Writes a list of instructions which evaluated on LGO standard-generators yield
the diagonal matrix of the input. }

 

\subsection{\textcolor{Chapter }{DiagonalDecompositionNC}}
\logpage{[ 2, 7, 25 ]}\nobreak
\hyperdef{L}{X86767C5E7F9FD6C1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagonalDecompositionNC({\mdseries\slshape stdgens, diam[, slp]})\index{DiagonalDecompositionNC@\texttt{DiagonalDecompositionNC}}
\label{DiagonalDecompositionNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 
\begin{itemize}
\item  \texttt{slp}: A list of instructions to evaluate diag (if slp was Input then this
instructions are added to slp). 
\item  \texttt{hres}: The the identity matrix. 
\end{itemize}




 Writes a list of instructions which evaluated on LGO standard-generators yield
the diagonal matrix of the input.

 This function works like \texttt{DiagonalDecomposition()} [\ref{DiagonalDecomposition}] but doesn't check the user input. }

 

\subsection{\textcolor{Chapter }{BruhatDecomposition}}
\logpage{[ 2, 7, 26 ]}\nobreak
\hyperdef{L}{X7D8C913E787C6BD5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BruhatDecomposition({\mdseries\slshape stdgens, g})\index{BruhatDecomposition@\texttt{BruhatDecomposition}}
\label{BruhatDecomposition}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{pgr}: A SLP (to compute $u_1,u_2,p_{sign}$ and $diag$) and the matrices $u_1, u_2, p_{sign}$ and $diag$ itself.



 Input: 
\begin{itemize}
\item  \texttt{stdgens}: The LGO standard-generators. 
\item  \texttt{g}: A matrix in SL$(d,q)$. 
\end{itemize}
 Uses \texttt{UnipotentDecomposition()}, \texttt{PermSLP()} and \texttt{DiagonalDecomposition()} to write a matrix $g \in SL(d,q)$ as $g = (u_1)^{-1} \cdot p_{sign} \cdot diag \cdot (u_2)^{-1}$ where $u_1,u_2$ are lower unitriangular matrices, $p_{sign}$ a monomial matrix with only $+1$ and $-1$ as non-zero entries and $diag$ a diagonal matrix.

 It furthermore yields a SLP that returns the above matrices if evaluated at
the LGO standard-generators. }

 

\subsection{\textcolor{Chapter }{BruhatDecompositionNC}}
\logpage{[ 2, 7, 27 ]}\nobreak
\hyperdef{L}{X79169D937C2B6C52}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BruhatDecompositionNC({\mdseries\slshape stdgens, g})\index{BruhatDecompositionNC@\texttt{BruhatDecompositionNC}}
\label{BruhatDecompositionNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{pgr}: A SLP (to compute $u_1,u_2,p_{sign}$ and $diag$) and the matrices $u_1, u_2, p_{sign}$ and $diag$ itself.



 Input: 
\begin{itemize}
\item  \texttt{stdgens}: The LGO standard-generators. 
\item  \texttt{g}: A matrix in SL$(d,q)$. 
\end{itemize}
 This function works like \texttt{BruhatDecomposition()} [\ref{BruhatDecomposition}] but uses \texttt{UnipotentDecompositionNC()}, \texttt{PermSLPNC()} and \texttt{DiagonalDecompositionNC()} instead of \texttt{UnipotentDecomposition()}, \texttt{PermSLP()} and \texttt{DiagonalDecomposition()}. }

 

\subsection{\textcolor{Chapter }{BruhatDecompositionWithTi}}
\logpage{[ 2, 7, 28 ]}\nobreak
\hyperdef{L}{X87DEB91D85E0D0A9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BruhatDecompositionWithTi({\mdseries\slshape stdgens, g})\index{BruhatDecompositionWithTi@\texttt{BruhatDecompositionWithTi}}
\label{BruhatDecompositionWithTi}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
\texttt{pgr}: A SLP (to compute $u_1,u_2,p_{sign}$, $diag$ and all transvections $t_{i,i-1}(\omega^{ell})$) and the matrices $u_1, u_2, p_{sign}$ and $diag$ itself.



 Input: 
\begin{itemize}
\item  \texttt{stdgens}: The LGO standard-generators. 
\item  \texttt{g}: A matrix in SL$(d,q)$. 
\end{itemize}
 Works as \texttt{BruhatDecomposition()} [\ref{BruhatDecomposition}] but replaces \texttt{UnipotentDecomposition()} by \texttt{UnipotentDecompositionWithTi()}. }

 

\subsection{\textcolor{Chapter }{BruhatDecompositionWithTiNC}}
\logpage{[ 2, 7, 29 ]}\nobreak
\hyperdef{L}{X7D31A8567A6EC122}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BruhatDecompositionWithTiNC({\mdseries\slshape stdgens, g})\index{BruhatDecompositionWithTiNC@\texttt{BruhatDecompositionWithTiNC}}
\label{BruhatDecompositionWithTiNC}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
slp: A list of instructions to compute $u1,u2,p_sign$ and $diag$.



 Input: 
\begin{itemize}
\item  \texttt{stdgens}: The LGO standard-generators. 
\item  \texttt{g}: A matrix in SL$(d,q)$. 
\end{itemize}
 This function works like \texttt{BruhatDecompositionWithTi()} [\ref{BruhatDecompositionWithTi}] but uses \texttt{UnipotentDecompositionWithTiNC()}, \texttt{PermSLPNC()} and \texttt{DiagonalDecompositionNC()} instead of \texttt{UnipotentDecompositionWithTi()}, \texttt{PermSLP()} and \texttt{DiagonalDecomposition()}. }

 }

 
\section{\textcolor{Chapter }{Local functions for UnipotentDecomposition}}\logpage{[ 2, 8, 0 ]}
\hyperdef{L}{X843D36E780023AE6}{}
{
 \label{Local} 

\subsection{\textcolor{Chapter }{TransvectionAtAlpha}}
\logpage{[ 2, 8, 1 ]}\nobreak
\hyperdef{L}{X7B744A4D8139CA95}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{TransvectionAtAlpha({\mdseries\slshape alpha})\index{TransvectionAtAlpha@\texttt{TransvectionAtAlpha}}
\label{TransvectionAtAlpha}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list of instructions to evaluate diam (if slp was Input then this
instructions are added to slp), the identity matrix



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Let slp be the list of instructions in
UnipotentDecomposition and Tipos denote the slots where transvections $t_{i,j}(\omega^{ell})$ for $0 \leq ell \leq \neq f$ are saved. This function computes $t_{i,j}(\alpha) = \prod t_{i,j}(\omega^{ell})^{a_{ell}}$ \cite[4.2]{CR1} where the exponents $a_{ell}$ are given by \texttt{CoefficientsPrimitiveElement()}. [\ref{CoefficientsPrimitiveElement}] \cite[p11]{CR1} }

 

\subsection{\textcolor{Chapter }{ShiftTransvections}}
\logpage{[ 2, 8, 2 ]}\nobreak
\hyperdef{L}{X818C33017C168949}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ShiftTransvections({\mdseries\slshape i})\index{ShiftTransvections@\texttt{ShiftTransvections}}
\label{ShiftTransvections}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
No output



 Let Ti be the set of transvections ${ t_{i,i-1}(\omega^{ell}) }$ and Ti{\textunderscore}1 the set of transvections ${ t_{i-1,i-2}(\omega^{ell}) }$.

 ShiftTransvections computes ${ t_{i+1,i}(\omega^{ell}) }$ for given Ti and Ti{\textunderscore}1 \cite[p12]{CR1}, stores them in the variable Ti and stores the transvections ${ t_{i,i-1}(\omega^{ell}) }$ in the variable Ti{\textunderscore}1.

 This corresponds to \cite[eq (7+8) p12 ]{CR1}. }

 

\subsection{\textcolor{Chapter }{FastShiftTransvecions}}
\logpage{[ 2, 8, 3 ]}\nobreak
\hyperdef{L}{X81D2B8187A323AB1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{FastShiftTransvecions({\mdseries\slshape i})\index{FastShiftTransvecions@\texttt{FastShiftTransvecions}}
\label{FastShiftTransvecions}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
No output



 Given $t_{2,1}$ we compute $t_{i,i-1}$ using fast exponentation. This algorithm will be called in each step of the
main loop and is more efficient than calling ShiftTransvections [\ref{ShiftTransvections}] (r-2) times. }

 

\subsection{\textcolor{Chapter }{BackShiftTransvections}}
\logpage{[ 2, 8, 4 ]}\nobreak
\hyperdef{L}{X7FBCCE387C74DDA8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BackShiftTransvections({\mdseries\slshape i})\index{BackShiftTransvections@\texttt{BackShiftTransvections}}
\label{BackShiftTransvections}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
No output



 This function is very similar to ShiftTransvections [\ref{ShiftTransvections}], except it works in the reverse order, namely BackShiftTransvections
computes $t_{i+1,i}$ given $t_{i+2,i}$ and $t_{i+3,i+2}$. }

 

\subsection{\textcolor{Chapter }{FastBackShiftTransvections}}
\logpage{[ 2, 8, 5 ]}\nobreak
\hyperdef{L}{X8285DDDE7B527C71}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{FastBackShiftTransvections({\mdseries\slshape i})\index{FastBackShiftTransvections@\texttt{FastBackShiftTransvections}}
\label{FastBackShiftTransvections}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
No output



 As for ShiftTransvections [\ref{ShiftTransvections}] , we need an efficient way to compute BackShiftTransvections [\ref{BackShiftTransvections}] multiple times in a row. }

 }

 
\section{\textcolor{Chapter }{Local functions for UnipotentDecompositionWithTi}}\logpage{[ 2, 9, 0 ]}
\hyperdef{L}{X7FFE0D2B8402676E}{}
{
 \label{LocalWithTi} 

\subsection{\textcolor{Chapter }{TransvectionAtAlpha2}}
\logpage{[ 2, 9, 1 ]}\nobreak
\hyperdef{L}{X84EB3C7F7C987F42}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{TransvectionAtAlpha2({\mdseries\slshape i, alpha})\index{TransvectionAtAlpha2@\texttt{TransvectionAtAlpha2}}
\label{TransvectionAtAlpha2}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{ComputeAllTransvections}}
\logpage{[ 2, 9, 2 ]}\nobreak
\hyperdef{L}{X80EFD16E868DDD55}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ComputeAllTransvections({\mdseries\slshape })\index{ComputeAllTransvections@\texttt{ComputeAllTransvections}}
\label{ComputeAllTransvections}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
No output.



 We first compute all the Ti for $i \geq 3$ and add them to the SLP. This are eq (7) and (8) p12 in References \cite[eq (7+8) p12 ]{CR1}. used instead of Schift- and BackshiftTransvections [\ref{ShiftTransvections} and \ref{BackShiftTransvections}]. }

 }

 }

 
\chapter{\textcolor{Chapter }{Bruhat Decomposition for the special unitary group (SU)}}\label{BDSU}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X81F906A77DFCFC36}{}
{
 In progress. 
\section{\textcolor{Chapter }{Functions}}\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X86FA580F8055B274}{}
{
 \label{Functions for SU} 

\subsection{\textcolor{Chapter }{LGOStandardGensSU}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X85E063C87EC6CCA3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LGOStandardGensSU({\mdseries\slshape i, alpha})\index{LGOStandardGensSU@\texttt{LGOStandardGensSU}}
\label{LGOStandardGensSU}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{UnitriangularDecompositionSUEven}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X7F6ECD7380D6D2A0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnitriangularDecompositionSUEven({\mdseries\slshape i, alpha})\index{UnitriangularDecompositionSUEven@\texttt{UnitriangularDecompositionSUEven}}
\label{UnitriangularDecompositionSUEven}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{UnitriangularDecompositionSUOdd}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X85795AD27BFECB19}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnitriangularDecompositionSUOdd({\mdseries\slshape i, alpha})\index{UnitriangularDecompositionSUOdd@\texttt{UnitriangularDecompositionSUOdd}}
\label{UnitriangularDecompositionSUOdd}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{UnitriangularDecompositionSU}}
\logpage{[ 3, 1, 4 ]}\nobreak
\hyperdef{L}{X79E30D6E7DD8291D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnitriangularDecompositionSU({\mdseries\slshape i, alpha})\index{UnitriangularDecompositionSU@\texttt{UnitriangularDecompositionSU}}
\label{UnitriangularDecompositionSU}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{CoefficientsPrimitiveElementS}}
\logpage{[ 3, 1, 5 ]}\nobreak
\hyperdef{L}{X793211108385A4F2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CoefficientsPrimitiveElementS({\mdseries\slshape i, alpha})\index{CoefficientsPrimitiveElementS@\texttt{CoefficientsPrimitiveElementS}}
\label{CoefficientsPrimitiveElementS}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{BruhatDecompositionSU}}
\logpage{[ 3, 1, 6 ]}\nobreak
\hyperdef{L}{X79AD1007829F87F8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BruhatDecompositionSU({\mdseries\slshape gens, g})\index{BruhatDecompositionSU@\texttt{BruhatDecompositionSU}}
\label{BruhatDecompositionSU}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{MonomialSLPSUOdd}}
\logpage{[ 3, 1, 7 ]}\nobreak
\hyperdef{L}{X7B8E470078522BF4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MonomialSLPSUOdd({\mdseries\slshape arg})\index{MonomialSLPSUOdd@\texttt{MonomialSLPSUOdd}}
\label{MonomialSLPSUOdd}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{MonomialSLPSUEven}}
\logpage{[ 3, 1, 8 ]}\nobreak
\hyperdef{L}{X82DB86F379904ADB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MonomialSLPSUEven({\mdseries\slshape arg})\index{MonomialSLPSUEven@\texttt{MonomialSLPSUEven}}
\label{MonomialSLPSUEven}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{CheckContinue}}
\logpage{[ 3, 1, 9 ]}\nobreak
\hyperdef{L}{X7A69AFAE8637E93F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CheckContinue({\mdseries\slshape i, alpha})\index{CheckContinue@\texttt{CheckContinue}}
\label{CheckContinue}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{CycleFromPermutation}}
\logpage{[ 3, 1, 10 ]}\nobreak
\hyperdef{L}{X86D4EC5985EDD4FF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CycleFromPermutation({\mdseries\slshape i, alpha})\index{CycleFromPermutation@\texttt{CycleFromPermutation}}
\label{CycleFromPermutation}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{CycleFromListMine}}
\logpage{[ 3, 1, 11 ]}\nobreak
\hyperdef{L}{X7A03D6777C11BB61}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CycleFromListMine({\mdseries\slshape i, alpha})\index{CycleFromListMine@\texttt{CycleFromListMine}}
\label{CycleFromListMine}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{DiagSLPSUOdd}}
\logpage{[ 3, 1, 12 ]}\nobreak
\hyperdef{L}{X7D83424581E15CB1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagSLPSUOdd({\mdseries\slshape i, alpha})\index{DiagSLPSUOdd@\texttt{DiagSLPSUOdd}}
\label{DiagSLPSUOdd}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{DiagSLPSU}}
\logpage{[ 3, 1, 13 ]}\nobreak
\hyperdef{L}{X78315BFA86EC337A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagSLPSU({\mdseries\slshape i, alpha})\index{DiagSLPSU@\texttt{DiagSLPSU}}
\label{DiagSLPSU}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{DiagSLPSUEven}}
\logpage{[ 3, 1, 14 ]}\nobreak
\hyperdef{L}{X7A10BC39849272DC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagSLPSUEven({\mdseries\slshape i, alpha})\index{DiagSLPSUEven@\texttt{DiagSLPSUEven}}
\label{DiagSLPSUEven}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 }

 }

 
\chapter{\textcolor{Chapter }{Bruhat Decomposition for the symplectic group (Sp)}}\label{BDSp}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X82E5676778771C49}{}
{
 In progress. 
\section{\textcolor{Chapter }{Functions}}\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X86FA580F8055B274}{}
{
 \label{Functions for Sp} 

\subsection{\textcolor{Chapter }{LGOStandardGensSp}}
\logpage{[ 4, 1, 1 ]}\nobreak
\hyperdef{L}{X82E6CC80818C226B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{LGOStandardGensSp({\mdseries\slshape i, alpha})\index{LGOStandardGensSp@\texttt{LGOStandardGensSp}}
\label{LGOStandardGensSp}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{UnitriangularDecompositionSp}}
\logpage{[ 4, 1, 2 ]}\nobreak
\hyperdef{L}{X7EE5A2267DAE098B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UnitriangularDecompositionSp({\mdseries\slshape arg})\index{UnitriangularDecompositionSp@\texttt{UnitriangularDecompositionSp}}
\label{UnitriangularDecompositionSp}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{MonomialSLPSp}}
\logpage{[ 4, 1, 3 ]}\nobreak
\hyperdef{L}{X84615263789182BE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{MonomialSLPSp({\mdseries\slshape arg})\index{MonomialSLPSp@\texttt{MonomialSLPSp}}
\label{MonomialSLPSp}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{DiagSLPSp}}
\logpage{[ 4, 1, 4 ]}\nobreak
\hyperdef{L}{X7F37F4B28245472E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{DiagSLPSp({\mdseries\slshape arg})\index{DiagSLPSp@\texttt{DiagSLPSp}}
\label{DiagSLPSp}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 

\subsection{\textcolor{Chapter }{BruhatDecompositionSp}}
\logpage{[ 4, 1, 5 ]}\nobreak
\hyperdef{L}{X7EABBF4F7A4DBF8A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{BruhatDecompositionSp({\mdseries\slshape gens, g})\index{BruhatDecompositionSp@\texttt{BruhatDecompositionSp}}
\label{BruhatDecompositionSp}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
true



 Let $\alpha \in GF(p^f)$, $\alpha = \sum a_l \omega^l$, $\omega$ a primitive element. Suppose further that Tipos is a list of transvections of
the form ${ t_{i,i-1}(\omega^{ell}) }$,$ 2 \leq i \leq d$, $0 \leq ell \leq \neq f$. Then this function computes $t_{i,i-1}( \alpha )$ by (Lemma 4.2) and saves the result in tvpos. }

 }

 }

 
\chapter{\textcolor{Chapter }{Bruhat Decomposition for the special orthogonal group (SO)}}\label{BDSO}
\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X83DA57E3833A7C57}{}
{
 In progress. 
\section{\textcolor{Chapter }{Functions}}\logpage{[ 5, 1, 0 ]}
\hyperdef{L}{X86FA580F8055B274}{}
{
 \label{Functions for SO} }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{examplebib.xml}

\addcontentsline{toc}{chapter}{References}

\immediate\write\pagenrlog{["Ind", 0, 0], \arabic{page},}
\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
