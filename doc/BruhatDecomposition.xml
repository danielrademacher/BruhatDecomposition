<?xml version="1.0" encoding="UTF-8"?>


<!DOCTYPE Book SYSTEM "gapdoc.dtd"
 [ <!ENTITY see '<Alt Only="LaTeX">$\to$</Alt><Alt Not="LaTeX">&#8594;</Alt>'>
 ]>

<Book Name="BruhatDecomposition">

<TitlePage>
  <Title>Bruhat Decomposition</Title>
  <Subtitle>Straight-line programs with memory and matrix Bruhat decomposition</Subtitle>
  <TitleComment>
  This implementation follows the ideas of "Straight-line programs with memory and
  matrix Bruhat decomposition" by Alice Niemeyer, Tomasz Popiel and Cheryl Praeger.
  </TitleComment>
  <Author>Alice Niemeyer
          <Email>alice.niemeyer@mathb.rwth-aachen.de</Email>
  </Author>
  <Author>Dominik Bernhardt
          <Email>bernhardt@mathb.rwth-aachen.de</Email>
  </Author>
  <Author>Daniel Rademacher
          <Email>daniel.rademacher@rwth-aachen.de</Email>
  </Author>
  <Author> Christian Singendonk
          <Email>christian.singendonk@rwth-aachen.de</Email>
  </Author>
  <Date>January 2019</Date>
  <Address>
  Lehrstuhl B für Mathematik<Br/>  Pontdriesch
  14/16<Br/> 52062 Aachen<Br/> (Germany)
  </Address>
  <Copyright>&copyright; 2019 by Alice Niemeyer, Dominik Bernhardt, Christian Singendonk and Daniel Rademacher
  </Copyright>
</TitlePage>

<TableOfContents/>

<Body>

    <Chapter Label="Foreword"><Heading>Foreword</Heading>
    
    Let <M>G</M> be the SL, SU, Sp or SO. Let g be an element in G.
    We want to write <M>g = u_1 \cdot w \cdot u_2</M> with <M>u_1</M> and <M>u_2</M> lower unitriangular matrices and <M>w</M> a monomial matrix. <P/>
    This is already implemented for:
    <List>
        <Item>
        Special linear group (SL) [<Ref Sect="BDSL"/>]
        </Item>
        <Item>
        Special unitary group (SU) [<Ref Sect="BDSU"/>]
        </Item>
        <Item>
        Symplectic group (Sp) [<Ref Sect="BDSp"/>]
        </Item>
    </List>
    
    </Chapter>
    
    
    <Chapter Label="BDSL"><Heading>Bruhat Decomposition for the special linear group (SL)</Heading>
        
    This implementation follows the ideas of "Straight-line programs with memory and matrix Bruhat decomposition"
    by Alice Niemeyer, Tomasz Popiel and Cheryl Praeger.<P/>
        
    Let <M>g \in SL(d,p^f)</M>.
    The Bruhat Decomposition computes <M>g = u_1 \cdot w \cdot u_2</M>, where
    <List>
        <Item>
        <M>u_1,u_2</M> are lower unitriangular matrices<P/>
        </Item>
        <Item>
        <M>w</M> is monomial matrix<P/>
        </Item>
    </List>
        
    In this algorithm we want to compute the Bruhat-Decomposition of <M>g</M>
    and give <M>g</M> (respectively <M>u_1,w</M> and <M>u_2</M>) as word in the
    "LGO standard generators". This generators can be found in "Constructive Recognition of Classical Groups in odd characteristic" by C. R. Leedham-Green and E. A. O’Brien. <Cite Key="CR1" Where="Chapter 3.1"/>
    
    <List>
        
    <Item> 1) While computing <M>u_1</M> (resp <M>u_2</M>) with some kind of Gauß-Algorithm,
    we express the matrices as product of transvections.
    For <M> 1 \leq j \leq \neq  i \leq d: t_{i,j}(\alpha) </M> is the matrix <M>T</M> with 1-entries on diagonal, <M>T_{i,j} = \alpha</M>, 0 elsewhere.
    Each <M>t_{i,j}(\alpha)</M> can be computed from <M>t_{2,1}(\alpha)</M> via recursion,
    where we have to distinguish the odd and even dimensons <Cite Key="CR1" Where="Lemma 4.2"/>.
    This again can be expressed as a product of <M>t_{2,1}(\omega^{ell})</M>
    (where <M>\omega</M> is a primitive element and <M>0 \leq ell \leq \neq f</M>).
    The transvections as words in the standard generators are described in
    <Cite Key="CR1" Where="Lemma 4.2"/>.
    This yields a decomposition of <M>u_1</M> and <M>u_2</M> in standard generators.</Item>
        
    <Item>2) In a further step we will decompose the monomial Matrix <M>w</M>
    in a "product of permutations" and a diagonal Matrix.
    ( How to associate this product of permutations with a product
    of generators is further described in "Implemented Subfunctions (Part I)" [<Ref Sect="FirstSect"/>]
    and "Decomposing the Monomial Matrix (Part III)" [<Ref Sect="FourthSect"/>] ). </Item>
        
    <Item>3) The last step is the decomposition of the diagonal Matrix in 2)
    as a word in the standard generators.</Item>
    
    </List>
        
    We won't do this matrix multiplications directly, but write them
    in a list to evaluate in a StraightLineProgram. <Cite Key="CR1" Where="Section 2"/>
    Although described differently in the paper, we sometimes will allow
    instructions to multiply more than two elements (eg during conjugating).
    This doesn't affect the optimality of an SLP much, but higly increases
    the readability of our implementation.<P/>

    <Label Name="ThreeBack"/>
    <Section Label="FirstSect"><Heading>Implemented Subfunctions (Part I)</Heading>
        
    Later we will need some additional functions. Why they are needed and where they are needed is described here. <P/>
    
    <List>
        
    <Item> <C>MakeSLP()</C>: After the <C>BruhatDecomposition()</C> we get a list of instructions to calculate the matrices we want using the LGO standard generators. <C>MakeSLP()</C> is used to get a SLP out of these instructions.</Item>
    
    <Item> <C>CoefficientsPrimitiveElement()</C>: It expresses an element w in a field fld as a linear combination of a Primitive Element. This is important for the transvections. <Cite Key="CR1" Where="Lemma 4.2"/></Item>
    
    <Item> <C>MyPermutationMat()</C>: Turns a permutation into a permutation matrix. We need it to calculate the LGO standard generator. </Item>
    
    <Item> <C>LGOStandardGens()</C>: This function computes the standard generators of SL
                    as given by C. R. Leedham-Green and E. A. O'Brien in
                    "Constructive Recognition of Classical Groups  in odd characteristic".
                    <Cite Key="CR1" Where="Chapter 3.1"/> <P/>
                    </Item>
    
    <Item> <C>HighestSlotOfSLP()</C>: The following function determines the highest slot of a  SLP constructed from the list slp will write in. This is important to glue SLPs together. </Item>
    
    <Item> <C>MatToWreathProd()</C> and <C>WreathProdToMat()</C>:
        In <C>PermSLP()</C> [<Ref Sect="PermSLP"/>] we want to transform the monomial matrix <M>w</M> given by
        <C>UnipotentDecomposition()</C> into a diagonal matrix.
        (The exact procedure is described in <C>PermSLP()</C> [<Ref Sect="PermSLP"/>])<P/>
        Since multiplying the LGO standard-generators <M>s,v</M> and <M>x</M> not only involves
        permutations but we also have to consider which non-zero entries are <M>+1</M> and
        which <M>-1</M>, we want to associate this matrices with permutations on <M>2d</M> points. (cf. Wreath-Product)<P/>

        <M>[s,v,x] \to Sym(2d), M \to </M> <C>Mwr</C> where
        <M>i^{Mwr} =  j</M>  and <M>(i+d)^{Mwr}= j+d</M> if <M> M_{i,j} = 1</M> and
        <M>i^{Mwr} = j+d</M> and <M>(i+d)^{Mwr}=  j</M>  if <M>M_{i,j} = -1</M>
        for <M>1 \leq i \leq d</M>.<P/>

        Due to their relation to wreath-products, we will call denote the image
        of a matrix <C>M</C><M> \in [s,v,x] </M> by <C>Mwr</C>. <P/>
                    
        In fact the association from <C>MatToWreathProd()</C> [<Ref Sect="MatToWreathProd"/>] is an isomorphism and we can associate to each
        permutation we compute during <C>PermSLP()</C> [<Ref Sect="PermSLP"/>] a signed permutation matrix (a monomial matrix with only <M>+1</M> and <M>-1</M> as non-zero entries). <P/>

        <M>M_{i,j} = 1</M>  if <M>i^{Mwr} =  j \leq d</M> and
        <M>M_{i,j} = -1</M> if <M>i^{Mwr} = j+d</M>
    </Item>
    
    <Item> <C>AEM()</C>: Write instructions for Ancient Egyptian Multiplication in slp. At several occasions we will need to compute a high power of some value saved in a memory slot.</Item>
    
    <Item> <C>TestIfMonomial()</C>: Tests if a given matrix M is monomial matrix. We use it to decide whether we are already finished in <C>UnipotentDecomposition()</C>.</Item>
    
    </List>
    
    For some functions also exist a NC version. See [<Ref Sect="SixtSect"/>].
            
    </Section>
        
    <Section Label="ThirdSect"><Heading>UnipotentDecomposition (Part II - a)</Heading>
  
    In this section is the <C>UnipotentDecomposition()</C> described. This method is used to compute the
    Unitriangular decomposition of the matrix <M>g</M>. [<Ref Sect="UnipotentDecomposition"/>] <P/>
            
    For this we use five local functions in the <C>UnipotentDecomposition()</C>. They are
    <C>TransvecAtAlpha()</C>,
    <C>ShiftTransvections()</C>, <C>FastShiftTransvections()</C>, <C>BackShiftTransvections()</C> and
    <C>FastBackShiftTransvections()</C>.
    For further information to these functions look at [<Ref Sect="Local"/>]. <P/>
    
    The difference to <C>UnipotentDecompositionWithTi()</C> [<Ref Sect="ThirdSect2"/>] is that this
    version won't store all the transvections <M>t_{i,i-1}(\omega^l)</M>.
    This will increase the runtime but reduce the memory usage by <M>(d-3) \cdot f</M> compared to
    the <C>UnipotentDecompositionWithTi()</C>.<P/>
            
    The function can be called for example by
<Log>
gap> d := 3;;
gap> q := 5;;
gap> L := SL(d, q);;
gap> m := PseudoRandom(L);;
gap> stdgens := LGOStandardGens(d, q);;
gap> UnipotentDecomposition( stdgens, g);;
</Log>
            
    </Section>
        
    <Section Label="ThirdSect2"><Heading>UnipotentDecomposition saving Transvections (Part II - b)</Heading>
  
    In this section is the <C>UnipotentDecompositionWithTi()</C> described.
    This method is used to compute the
    Unitriangular decomposition of the matrix <M>g</M>. [<Ref Sect="UnipotentDecompositionWithTi"/>] <P/>
    
    In this version we will store all the transvections <M>t_{i,i-1}(\omega^l)</M>.
    This will increase the memory usage by <M>(d-3) \cdot f</M> but reduce runtime.<P/>
  
    In <C>UnipotentDecompositionWithTi()</C> we use two local functions. They are
    <C>TransvectionAtAlpha()</C> and
    <C>ComputeAllTransvections()</C>. For further information to these functions look
    at [<Ref Sect="LocalWithTi"/>]. <P/>
    
    The function can be called for example by
<Log>
gap> d := 3;;
gap> q := 5;;
gap> L := SL(d, q);;
gap> m := PseudoRandom(L);;
gap> stdgens := LGOStandardGens(d, q);;
gap> UnipotentDecompositionWithTi( stdgens, g);;
</Log>

    </Section>
        
    <Section Label="FourthSect"><Heading>Decomposing the Monomial Matrix (Part III)</Heading>
  
    We use three functions to decompose the monomial matrix <M>w</M> we get from
    <C>UnipotentDecomposition()</C>. They are:
    <List>
        <Item> <C>PermutationMonomialMatrix()</C>: Find the permutation (in Sym(d) corresponding to the monomial matrix <M>w</M>) and <M>diag</M> a diagonal matrix, where <M>diag[i]</M> is the non-zero entry of row <M>i</M>. [<Ref Sect="PermutationMonomialMatrix"/>] </Item>
        <Item> <C>PermSLP()</C>:
        In this function we will transform a monomial matrix <M>w \in </M>SL<M>(d,q)</M> into a diagonal matrix <M>diag</M>. Using only the standard-generators <M>s,v,x</M>. This will lead to a monomial matrix <M>p_{sign}</M> with only <M>\pm 1</M> in non-zero entries and <M>p_{sign} \cdot diag = w</M> (i.e. <M>diag = (p_{sign})^{-1} \cdot w</M> ).<P/>
                Furthermore we will return list <C>slp</C> of instructions which will (when evaluated at the LGO standard-generators) yield <M>diag</M>.

            It is sufficient for <M>diag</M> to be diagonal, if the permutation associated with <M>w</M> (i.e. <M>i^{\pi_w} = j</M> if <M>M_{i,j} \neq 0</M>) is the inverse of the permutation associated to <M>p_{sign}</M> (again only to Sym(<M>d</M>) ).<P/>

            In <C>PermSLP()</C> we thus transform <M>\pi_w</M> to <M>()</M> using only <M>\{ \pi_s, \pi_v, \pi_x \}</M>.
            In order to know <M>diag</M> without computing all matrix multiplications, (we don't know the signs of <M>p_{sign}</M>), we compute a second permutation simultaneously (here using their identification with permutations in Sym<M>(2d)</M> and identifying <M>\{ \pi_s, \pi_v, \pi_x \}</M> with <M>\{s,v,x\}</M> ). [<Ref Sect="PermSLP"/>] </Item>
        <Item> <C>DiagonalDecomposition()</C>: Writes a list of instructions which evaluated on LGO standard-generators yield the diagonal matrix of the input. [<Ref Sect="DiagonalDecomposition"/>]</Item>
    </List>
    
    To these three functions is also a NC version implemented. See [<Ref Sect="SixtSect"/>].

    </Section>
        
    <Section Label="FifthSect"><Heading>Main Function (Part IV)</Heading>
  
    In <C>BruhatDecomposition()</C> [<Ref Sect="BruhatDecomposition"/>] we put everything together. We use the three functions <C>UnipotentDecomposition()</C> [<Ref Sect="UnipotentDecomposition"/>], <C>PermSLP()</C> [<Ref Sect="PermSLP"/>] and <C>DiagonalDecomposition()</C> [<Ref Sect="DiagonalDecomposition"/>] to compute matrices with <M>u_1^{-1} \cdot p_{sign} \cdot diag \cdot u_2^{-1} = g</M> and a SLP <C>pgr</C> that computes these matrices with the LGO standard generators.<P/>
    
    Here is an exampel:
<Log>
gap> mat := [ [ Z(5)^2, Z(5)^0, Z(5)^2 ],
>             [ Z(5)^3, 0*Z(5), 0*Z(5) ],
>             [ 0*Z(5), Z(5)^2, Z(5)^2 ] ];;
gap> L := BruhatDecomposition(LGOStandardGens(3,5), mat);
gap> result := ResultOfStraightLineProgram(L[1], LGOStandardGens(3,5));
</Log>
    
    <C>BruhatDecompositionWithTi()</C> [<Ref Sect="BruhatDecompositionWithTi"/>] works like <C>BruhatDecomposition()</C> [<Ref Sect="BruhatDecomposition"/>] but uses <C>UnipotentDecompositionWithTi()</C> [<Ref Sect="UnipotentDecompositionWithTi"/>] instead of <C>UnipotentDecomposition()</C> [<Ref Sect="UnipotentDecomposition"/>]. <P/>
    
    You can use it in the same way like <C>BruhatDecomposition()</C>:
<Log>
gap> mat := [ [ Z(5)^2, Z(5)^0, Z(5)^2 ],
>             [ Z(5)^3, 0*Z(5), 0*Z(5) ],
>             [ 0*Z(5), Z(5)^2, Z(5)^2 ] ];;
gap> L := BruhatDecompositionWithTi(LGOStandardGens(3,5), mat);
gap> result := ResultOfStraightLineProgram(L[1], LGOStandardGens(3,5));
</Log>
    
    To both functions is also a NC version implemented. See [<Ref Sect="SixtSect"/>].

    </Section>
        
    <Section Label="SixtSect"><Heading>NC Version</Heading>

    Here is the NC version of the Bruhat Decomposition described.
    In all implemented functions are all used functions replaced through their NC version (if one exists).
    Moreover are all checks from functions of MyBruhatDecomposition removed.<P/>

    These functions has been modified by this actions and got a NC Version:
    <List>
            <Item><C>MakeSLP()</C>[<Ref Sect="MakeSLP"/>] <M>\to</M> <C>MakeSLPNC()</C>[<Ref Sect="MakeSLPNC"/>] (uses the NC version of <C>StraightLineProgram</C>)</Item>
            <Item><C>MyPermutationMat()</C> [<Ref Sect="MyPermutationMat"/>] <M>\to</M> <C>MyPermutationMatNC()</C> [<Ref Sect="MyPermutationMatNC"/>] (uses the NC version of <C>ConvertToMatrixRep</C>)</Item>
            <Item><C>LGOStandardGens()</C> [<Ref Sect="LGOStandardGens"/>] <M>\to</M> <C>LGOStandardGensNC()</C> [<Ref Sect="LGOStandardGensNC"/>] (uses the NC version of <C>MyPermutationMat()</C>)</Item>
            <Item><C>MatToWreathProd()</C> [<Ref Sect="MatToWreathProd"/>] <M>\to</M> <C>MatToWreathProdNC()</C> [<Ref Sect="MatToWreathProdNC"/>] (no checks for user input)</Item>
            <Item><C>TestIfMonomial()</C> [<Ref Sect="TestIfMonomial"/>] <M>\to</M> <C>TestIfMonomialNC()</C> [<Ref Sect="TestIfMonomialNC"/>] (no checks for user input)</Item>
            <Item><C>UnipotentDecomposition()</C> [<Ref Sect="UnipotentDecomposition"/>] <M>\to</M> <C>UnipotentDecompositionNC()</C> [<Ref Sect="UnipotentDecompositionNC"/>] (no checks for user input)</Item>
            <Item><C>UnipotentDecompositionWithTi()</C> [<Ref Sect="UnipotentDecompositionWithTi"/>] <M>\to</M> <C>UnipotentDecompositionWithTiNC()</C> [<Ref Sect="UnipotentDecompositionWithTiNC"/>] (no checks for user input)</Item>
            <Item><C>PermutationMonomialMatrix()</C> [<Ref Sect="PermutationMonomialMatrix"/>] <M>\to</M> <C>PermutationMonomialMatrixNC()</C> [<Ref Sect="PermutationMonomialMatrixNC"/>] (no checks for user input)</Item>
            <Item><C>PermSLP()</C> [<Ref Sect="PermSLP"/>] <M>\to</M> <C>PermSLPNC()</C> [<Ref Sect="PermSLPNC"/>] (no checks for unser input and uses <C>PermutationMonomialMatrixNC()</C>)</Item>
            <Item><C>DiagonalDecomposition()</C> [<Ref Sect="DiagonalDecomposition"/>] <M>\to</M> <C>DiagonalDecompositionNC()</C> [<Ref Sect="DiagonalDecompositionNC"/>] (no checks for user input)</Item>
            <Item><C>BruhatDecomposition()</C> [<Ref Sect="BruhatDecomposition"/>] <M>\to</M> <C>BruhatDecompositionNC()</C> [<Ref Sect="BruhatDecompositionNC"/>] (uses <C>UnipotentDecompositionNC()</C>, <C>PermSLPNC()</C> and <C>DiagonalDecompositionNC</C>)</Item>
            <Item><C>BruhatDecompositionWithTi()</C> [<Ref Sect="BruhatDecompositionWithTi"/>] <M>\to</M> <C>BruhatDecompositionWithTiNC()</C> [<Ref Sect="BruhatDecompositionWithTiNC"/>] (uses <C>UnipotentDecompositionWithTiNC()</C>, <C>PermSLPNC()</C> and <C>DiagonalDecompositionNC()</C>)</Item>
    </List>

    </Section>
        
        <Section><Heading>Functions</Heading>
                <Label Name="Functions"/>

                <ManSection>
                <Func Name="MakeSLP" Arg="slp, genlen"/>
                <Returns>An SLP using the instructions of slp and genlen inputs</Returns>
                <Description>
                    Input:
                    <List>
                    <Item> <C>slp</C>: A list of instructions for a straight-line program </Item>
                    <Item> <C>genlen</C>: The number of inputs for our SLP (ie the number of generators ) </Item>
                    </List>
                    
                    Uses <C>StraightLineProgram</C> to make an SLP out of the instructions from slp and
                    dependent on genlen.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="MakeSLPNC" Arg="slp, genlen"/>
                <Returns>An SLP using the instructions of slp and genlen inputs</Returns>
                <Description>
                    This function works like <C>MakeSLP()</C> [<Ref Sect="MakeSLP"/>] but uses
                    <C>StraightLineProgramNC</C> instead of <C>StraightLineProgram</C>.
                </Description>
                </ManSection>
  
                <ManSection>
                <Func Name="CoefficientsPrimitiveElement" Arg="fld, alpha"/>
                <Returns>A vector <M>c</M> such that for <M>\omega</M> primitive
                element in <C>fld</C> is <M> \sum c[i] \omega^{(i-1)} = </M><C>alpha</C></Returns>
                 <Description>
                    Input:
                    <List>
                    <Item> <C>fld</C>: A field </Item>
                    <Item> <C>alpha</C> : An element of <C>fld</C> </Item>
                    </List>
                    The function has been written by Thomas Breuer.
                    It expresses an element w in a field fld as a linear combination of a Primitive Element.
                 </Description>
                </ManSection>
  
                <ManSection>
                <Func Name="MyPermutationMat" Arg="perm, dim, fld"/>
                <Returns>The permutation matrix <M>res \in fld^{dim \times dim}</M> of <C>perm</C>
                            (i.e. <M>res_{i,j} = 1_{fld}</M> if <M>i^{perm} = j</M>).</Returns>
                 <Description>
                    Input:
                    <List>
                    <Item> <C>perm</C>: A permutation </Item>
                    <Item> <C>dim</C> : A natural number </Item>
                    <Item> <C>fld</C> : A field </Item>
                    </List>
                    Given a permutation <C>perm</C>, an integer <C>dim</C><M> > 0</M> and a field <C>fld</C>, this function computes
                    the permutation matrix <M>res \in fld^{dim \times dim}</M>.
                 </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="MyPermutationMatNC" Arg="perm, dim, fld"/>
                <Returns>The permutation matrix <M>res \in fld^{dim \times dim}</M> of <C>perm</C>
                            (i.e. <M>res_{i,j} = 1_{fld}</M> if <M>i^{perm} = j</M>).</Returns>
                 <Description>
                    This function works like <C>MyPermutationMat()</C> [<Ref Sect="MyPermutationMat"/>] but uses
                    <C>ConvertToMatrixRepNC</C> instead of <C>ConvertToMatrixRep</C>.
                 </Description>
                </ManSection>
  
                <ManSection>
                <Func Name="LGOStandardGens" Arg="d, q"/>
                <Returns><C>stdgens</C> the LGO standard-generators of <M>SL(d,q)</M>.</Returns>
                <Description>
                    Input:
                    <List>
                    <Item> <C>d</C>: the dimension of our matrix </Item>
                    <Item> <C>q</C>: A prime power <M>q = p^f</M>, where <M>F_q</M> ist the field whereover the matrices are defined </Item>
                    </List>
                    This function computes the standard generators of SL
                    as given by C. R. Leedham-Green and E. A. O'Brien in
                    "Constructive Recognition of Classical Groups  in odd characteristic".
                    <Cite Key="CR2"/> <Cite Key="CR1" Where="Chapter 3.1"/>
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="LGOStandardGensNC" Arg="d, q"/>
                <Returns><C>stdgens</C> the LGO standard-generators of <M>SL(d,q)</M>.</Returns>
                <Description>
                Input:
                    <List>
                    <Item> <C>d</C>: the dimension of our matrix </Item>
                    <Item> <C>q</C>: A prime power <M>q = p^f</M>, where <M>F_q</M> ist the field whereover the matrices are defined </Item>
                    </List>
                    This function works like <C>LGOStandardGens()</C> [<Ref Sect="LGOStandardGens"/>] but uses
                    <C>MyPermutationMatNC()</C> instead of <C>MyPermutationMat()</C>.
                </Description>
                </ManSection>
  
                <ManSection>
                <Func Name="HighestSlotOfSLP" Arg="slp"/>
                <Returns><C>highestslot</C> the number of slots the SLP <C>slp</C> will need if evaluated.</Returns>
                <Description>
                Input:
                <List>
                <Item> <C>slp</C>: A list of instructions satisfying the properties for an SLP </Item>
                </List>

                The function determines the highest slot a SLP constructed from the list slp will write in.
                </Description>
                </ManSection>
  
                <ManSection>
                <Func Name="MatToWreathProd" Arg="M"/>
                <Returns><C>perm</C>: the permutation <C>Mwr</C> (see Describtion)</Returns>
                <Description>
                    Input:
                    <List>
                    <Item> <C>M</C>: A signed permutation matrix. </Item>
                    </List>
                
                    In <C>PermSLP()</C> [<Ref Sect="PermSLP"/>] we want to transform the monomial matrix <M>w</M> given by
                    <C>UnipotentDecomposition()</C> into a diagonal matrix.
                    (The exact procedure is described in <C>PermSLP()</C> [<Ref Sect="PermSLP"/>])<P/>
                    Since multiplying the LGO standard-generators <M>s,v</M> and <M>x</M> not only involves
                    permutations but we also have to consider which non-zero entries are <M>+1</M> and
                    which <M>-1</M>, we want to associate this matrices with permutations on <M>2d</M> points. (cf. Wreath-Product)<P/>

                    <M>[s,v,x] \to Sym(2d), M \to </M> <C>Mwr</C> where
                    <M>i^{Mwr} =  j</M>  and <M>(i+d)^{Mwr}= j+d</M> if <M> M_{i,j} = 1</M> and
                    <M>i^{Mwr} = j+d</M> and <M>(i+d)^{Mwr}=  j</M>  if <M>M_{i,j} = -1</M>
                    for <M>1 \leq i \leq d</M>.<P/>

                    Due to their relation to wreath-products, we will call denote the image
                    of a matrix <C>M</C><M> \in [s,v,x] </M> by <C>Mwr</C>.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="MatToWreathProdNC" Arg="M"/>
                <Returns><C>perm</C>: the permutation <C>Mwr</C> (see Describtion)</Returns>
                <Description>
                    Input:
                    <List>
                    <Item> <C>M</C>: signed permutation matrix. </Item>
                    </List>
                    
                    This function works like <C>MatToWreathProd()</C> [<Ref Sect="MatToWreathProd"/>] but doesn't check the user input.
                
                </Description>
                </ManSection>
  
                <ManSection>
                <Func Name="WreathProdToMat" Arg="perm, dim, fld"/>
                <Returns><C>res</C>: The Matrix <C>M</C> satisfying the properties from the description.</Returns>
                <Description>
                    Input:
                    <List>
                    <Item> <C>perm</C>: A permutation in Sym<M>(2d)</M> sth. <M>\{ \{i,i+d \}\}: 1 \leq i \leq d</M> are blocks </Item>
                    <Item> <C>dim</C>: The dimension of the matrix we want perm send to </Item>
                    <Item> <C>fld</C>: The field whereover the matrix is defined </Item>
                    </List>
                    In fact the association from <C>MatToWreathProd()</C> [<Ref Sect="MatToWreathProd"/>] is an isomorphism and we can associate to each
                    permutation we compute during <C>PermSLP()</C> [<Ref Sect="PermSLP"/>] a signed permutation matrix.

                    <M>M_{i,j} = 1</M>  if <M>i^{Mwr} =  j \leq d</M> and
                    <M>M_{i,j} = -1</M> if <M>i^{Mwr} = j+d</M>
                </Description>
                </ManSection>
  
                <ManSection>
                <Func Name="AEM" Arg="spos, respos, tmppos, k"/>
                <Returns><C>instr</C>: Lines of an SLP that will (when evaluated) take the value <M>b</M> saved in <C>spos</C> and write <M>b^k</M> in <C>respos</C></Returns>
                <Description>
                    Input:
                    <List>
                    <Item> <C>spos</C>: The memory slot, where a value b is saved in. </Item>
                    <Item> <C>respos</C>: The memory slot we want the exponentation to be written in. </Item>
                    <Item> <C>tmppos</C>: A memory slot for temporary results. </Item>
                    <Item> <C>k</C>: An integer. </Item>
                    </List>
                    
                    At several occasions we will need to compute a high power of
                    some value saved in a memory slot. For this purpose this function is a
                    variaton of AEM (Ancient Egytian Multiplication).<P/>
      
                    Remark: <C>tmpos</C> and <C>respos</C> must differ. If <C>spos</C> = <C>respos</C> or <C>spos</C> = <C>tmpos</C> it will be overwritten.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="TestIfMonomial" Arg="M"/>
                <Returns>true if <C>M</C> is Monomial, false else.</Returns>
                <Description>
                    Input:
                    <List>
                    <Item> <C>M</C>: A matrix. </Item>
                    </List>
                     Tests if a given matrix <C>M</C> is a monomial matrix. There is a function in GAP, however it
                     does not seem to work for SL<M>(d,q)</M>.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="TestIfMonomialNC" Arg="M"/>
                <Returns>true if <C>M</C> is Monomial, false else.</Returns>
                <Description>
                    Input:
                    <List>
                    <Item> <C>M</C>: A matrix. </Item>
                    </List>
                    
                    This function works like <C>TestIfMonomial()</C> [<Ref Sect="TestIfMonomial"/>] but doesn't check the user input.
                    
                </Description>
                </ManSection>
  
                <ManSection>
                <Func Name="Transvections2" Arg="stdgens, omega, slp, pos"/>
                <Returns>slp: The list of instruction with additional instructions writing
                                <M>t_{2,1}(\omega^{ell})</M> in Slot <M>pos[ell+1]</M> für <M> 0 \leq ell \leq \neq f</M>.</Returns>
                <Description>
                    Input:
                    <List>
                    <Item> <C>stdgens</C>: The LGO standard-generators of SL<M>(d,q)</M>. </Item>
                    <Item> <C>omega</C>: A primitive element of <M>GF(q)</M>. </Item>
                    <Item> <C>slp</C>: A list of instructions. </Item>
                    <Item> <C>pos</C>: A list of numbers, denoting where to save the transvections
                            <M>t_{2,1}(\omega^{ell})</M> für <M>0 \leq ell \leq \neq  f</M>. </Item>
                    </List>
                
                    Let <C>stdgens</C> be the list of standard generators for SL<M>(d,p^f)</M> and let <M>\omega</M> be a primitive element of <M>G(p^f)</M>.
                    This function computes <M>T_2</M> and record what we do in <C>slp</C>.<P/>
                    
                    This function coincides with <Cite Key="CR1" Where="Equation (6), p12"/>.
                </Description>
                </ManSection>
  
                <ManSection>
                <Func Name="UnipotentDecomposition" Arg="arg"/>
                <Returns><C>slp</C>: A list of instructions yielding <M>u_1,u_2</M> if evaluated as SLP, <M>[u_1,g,u_2]</M> (the matrices of the Bruhat-Decomposition).</Returns>
                <Description>
                    Input:
                    <List>
                    <Item> <C>stdgens</C>: The LGO standard-generators. </Item>
                    <Item> <C>g</C>: A matrix in SL<M>(d,q)</M>. </Item>
                    </List>
                    Computes the Unitriangular decomposition of the matrix <M>g</M>.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="UnipotentDecompositionNC" Arg="arg"/>
                <Returns><C>slp</C>: A list of instructions yielding <M>u_1,u_2</M> if evaluated as SLP, <M>[u_1,g,u_2]</M> (the matrices of the Bruhat-Decomposition).</Returns>
                <Description>
                    This function works like <C>UnipotentDecomposition()</C> [<Ref Sect="UnipotentDecomposition"/>] but doesn't check the user input.
                </Description>
                </ManSection>
  
                <ManSection>
                <Func Name="UnipotentDecompositionWithTi" Arg="arg"/>
                <Returns><C>slp</C>: A list of instructions yielding <M>u_1,u_2</M> if evaluated as SLP, <M>[u_1,g,u_2]</M> (the matrices of the Bruhat-Decomposition).</Returns>
                <Description>
                    Input:
                    <List>
                    <Item> <C>stdgens</C>: The LGO standard-generators. </Item>
                    <Item> <C>g</C>: A matrix in SL<M>(d,q)</M>. </Item>
                    </List>
                    Compute the Bruhat decomposition of the matrix <C>g</C>, given the standard generators for the group.<P/>
                    
                    In this version we will store all the transvections <M>T_{i,i-1}(\omega^l)</M>.
                    This will increase the memory usage by <M>(d-3) \cdot f</M> but reduce runtime.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="UnipotentDecompositionWithTiNC" Arg="arg"/>
                <Returns><C>slp</C>: A list of instructions yielding <M>u_1,u_2</M> if evaluated as SLP, <M>[u_1,g,u_2]</M> (the matrices of the Bruhat-Decomposition).</Returns>
                <Description>
                    Input:
                    <List>
                    <Item> <C>stdgens</C>: The LGO standard-generators. </Item>
                    <Item> <C>g</C>: A matrix in SL<M>(d,q)</M>. </Item>
                    </List>
                    This function works like <C>UnipotentDecompositionWithTi()</C> [<Ref Sect="UnipotentDecompositionWithTi"/>] but doesn't check the user input.
                </Description>
                </ManSection>
  
                <ManSection>
                <Func Name="PermutationMonomialMatrix" Arg="M"/>
                <Returns>
                <List>
                    <Item> <C>diag</C>: The vector of non-zero entries where diag[i] is the non-zero entry of row i. </Item>
                    <Item> <C>perm</C>: The  permutation associated to <C>M</C> (ie <M>i^{perm} = j</M> if <M>M_{i,j} \neq 0</M>). </Item>
                </List>
                </Returns>
                <Description>
                Input:
                <List>
                    <Item> <C>M</C>: A monomial Matrix</Item>
                </List>
                    Find the permutation (in Sym<M>(d)</M> corresponding to the monomial matrix <C>M</C>).
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="PermutationMonomialMatrixNC" Arg="M"/>
                <Returns>
                <List>
                    <Item> <C>diag</C>: The vector of non-zero entries where diag[i] is the non-zero entry of row i. </Item>
                    <Item> <C>perm</C>: The  permutation associated to <C>M</C> (ie <M>i^{perm} = j</M> if <M>M_{i,j} \neq 0</M>). </Item>
                </List> </Returns>
                <Description>
                Input:
                <List>
                    <Item> <C>M</C>: A monomial Matrix</Item>
                </List>
                    This function works like <C>PermutationMonomialMatrix()</C> [<Ref Sect="PermutationMonomialMatrix"/>] but doesn't check the user input.
                </Description>
                </ManSection>
  
                <ManSection>
                <Func Name="PermSLP" Arg="stdgens, mat, [ slp ]"/>
                <Returns>
                <List>
                    <Item> <C>slp</C>: A list of instructions to evaluate <C>p_sign</C> (if <C>slp</C> was Input then this instructions are added to <C>slp</C>).</Item>
                    <Item> <C>p_sign</C>: The signed permutation matrix. </Item>
                    <Item> <C>mat</C>: The diagonal matrix <C>diag</C>.</Item>
                </List>
                </Returns>
                <Description>
                Input:
                <List>
                    <Item> <C>stdgens</C>: The LGO standard-generators. </Item>
                    <Item> <C>mat</C>: A monomial matrix (i.e. <M>w</M>). </Item>
                    <Item> <C>slp</C>: An already existing list of instructions. [optional]</Item>
                </List>
                
                In this function we will transform a monomial matrix <M>w \in </M>SL<M>(d,q)</M> into a diagonal matrix <M>diag</M>. Using only the standard-generators <M>s,v,x</M>. This will lead to a monomial matrix <M>p_{sign}</M> with only <M>\pm 1</M> in non-zero entries and <M>p_{sign} \cdot diag = w</M> (i.e. <M>diag = (p_{sign})^{-1} \cdot w</M> ).<P/>
                Furthermore we will return list <C>slp</C> of instructions which will (when evaluated at the LGO standard-generators) yield <M>diag</M>.

                It is sufficient for <M>diag</M> to be diagonal, if the permutation associated with <M>w</M> (i.e. <M>i^{\pi_w} = j</M> if <M>M_{i,j} \neq 0</M>) is the inverse of the permutation associated to <M>p_{sign}</M> (again only to Sym(<M>d</M>) ).<P/>

                In <C>PermSLP()</C> we thus transform <M>\pi_w</M> to <M>()</M> using only <M>\{ \pi_s, \pi_v, \pi_x \}</M>.
                In order to know <M>diag</M> without computing all matrix multiplications, (we don't know the signs of <M>p_{sign}</M>), we compute a second permutation simultaneously (here using their identification with permutations in Sym<M>(2d)</M> and identifying <M>\{ \pi_s, \pi_v, \pi_x \}</M> with <M>\{s,v,x\}</M> ).
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="PermSLPNC" Arg="stdgens, mat, [ slp ]"/>
                <Returns>
                <List>
                    <Item> <C>slp</C>: A list of instructions to evaluate <C>p_sign</C> (if <C>slp</C> was Input then this instructions are added to <C>slp</C>).</Item>
                    <Item> <C>p_sign</C>: The signed permutation matrix. </Item>
                    <Item> <C>mat</C>: The diagonal matrix <C>diag</C>.</Item>
                </List>
                </Returns>
                <Description>
                Input:
                <List>
                    <Item> <C>stdgens</C>: The LGO standard-generators. </Item>
                    <Item> <C>mat</C>: A monomial matrix (i.e. <M>w</M>). </Item>
                    <Item> <C>slp</C>: An already existing list of instructions. [optional]</Item>
                </List>
                
                This function works like <C>PermSLP()</C> [<Ref Sect="PermSLP"/>] but doesn't check the user input.
                </Description>
                </ManSection>
  
                <ManSection>
                <Func Name="DiagonalDecomposition" Arg="stdgens, diam, [ slp]"/>
                <Returns>
                <List>
                    <Item> <C>slp</C>: A list of instructions to evaluate diag (if slp was Input then this instructions are added to slp). </Item>
                    <Item> <C>hres</C>: The the identity matrix. </Item>
                </List>
                </Returns>
                <Description>
                Input:
                <List>
                    <Item> <C>stdgens</C>: The LGO standard-generators. </Item>
                    <Item> <C>diam</C>: A diagonal matrix  (e.g. <M>diag</M>). </Item>
                    <Item> <C>slp</C>: An already existing list of instructions. [optional]</Item>
                </List>
                Writes a list of instructions which evaluated on LGO standard-generators yield the diagonal matrix of the input.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="DiagonalDecompositionNC" Arg="stdgens, diam, [ slp]"/>
                <Returns>
                <List>
                    <Item> <C>slp</C>: A list of instructions to evaluate diag (if slp was Input then this instructions are added to slp). </Item>
                    <Item> <C>hres</C>: The the identity matrix. </Item>
                </List></Returns>
                <Description>
                    Writes a list of instructions which evaluated on LGO standard-generators yield the diagonal matrix of the input.<P/>
                    This function works like <C>DiagonalDecomposition()</C> [<Ref Sect="DiagonalDecomposition"/>] but doesn't check the user input.
                </Description>
                </ManSection>
  
                <ManSection>
                <Func Name="BruhatDecomposition" Arg="stdgens, g"/>
                <Returns><C>pgr</C>: A SLP (to compute <M>u_1,u_2,p_{sign}</M> and <M>diag</M>) and the matrices <M>u_1, u_2, p_{sign}</M> and <M>diag</M> itself.</Returns>
                <Description>
                Input:
                <List>
                    <Item> <C>stdgens</C>: The LGO standard-generators. </Item>
                    <Item> <C>g</C>: A matrix in SL<M>(d,q)</M>. </Item>
                </List>
                Uses <C>UnipotentDecomposition()</C>, <C>PermSLP()</C> and <C>DiagonalDecomposition()</C> to write a matrix <M>g \in SL(d,q)</M> as <M>g = (u_1)^{-1} \cdot p_{sign} \cdot diag \cdot (u_2)^{-1}</M> where <M>u_1,u_2</M> are lower unitriangular matrices, <M>p_{sign}</M> a monomial matrix with only <M>+1</M> and <M>-1</M> as non-zero entries and <M>diag</M> a diagonal matrix.<P/>
                    It furthermore yields a SLP that returns the above matrices if evaluated at the LGO standard-generators.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="BruhatDecompositionNC" Arg="stdgens, g"/>
                <Returns><C>pgr</C>: A SLP (to compute <M>u_1,u_2,p_{sign}</M> and <M>diag</M>) and the matrices <M>u_1, u_2, p_{sign}</M> and <M>diag</M> itself.</Returns>
                <Description>
                Input:
                <List>
                    <Item> <C>stdgens</C>: The LGO standard-generators. </Item>
                    <Item> <C>g</C>: A matrix in SL<M>(d,q)</M>. </Item>
                </List>
                This function works like <C>BruhatDecomposition()</C> [<Ref Sect="BruhatDecomposition"/>] but uses <C>UnipotentDecompositionNC()</C>, <C>PermSLPNC()</C> and <C>DiagonalDecompositionNC()</C> instead of <C>UnipotentDecomposition()</C>, <C>PermSLP()</C> and <C>DiagonalDecomposition()</C>.
                
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="BruhatDecompositionWithTi" Arg="stdgens, g"/>
                <Returns><C>pgr</C>: A SLP (to compute <M>u_1,u_2,p_{sign}</M>, <M>diag</M> and all transvections <M>t_{i,i-1}(\omega^{ell})</M>) and the matrices <M>u_1, u_2, p_{sign}</M> and <M>diag</M> itself.</Returns>
                <Description>
                Input:
                <List>
                    <Item> <C>stdgens</C>: The LGO standard-generators. </Item>
                    <Item> <C>g</C>: A matrix in SL<M>(d,q)</M>. </Item>
                </List>
                Works as <C>BruhatDecomposition()</C> [<Ref Sect="BruhatDecomposition"/>] but replaces <C>UnipotentDecomposition()</C>
                by <C>UnipotentDecompositionWithTi()</C>.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="BruhatDecompositionWithTiNC" Arg="stdgens, g"/>
                <Returns>slp: A list of instructions to compute <M>u1,u2,p_sign</M> and <M>diag</M>.</Returns>
                <Description>
                Input:
                <List>
                    <Item> <C>stdgens</C>: The LGO standard-generators. </Item>
                    <Item> <C>g</C>: A matrix in SL<M>(d,q)</M>. </Item>
                </List>
                This function works like <C>BruhatDecompositionWithTi()</C> [<Ref Sect="BruhatDecompositionWithTi"/>] but uses <C>UnipotentDecompositionWithTiNC()</C>, <C>PermSLPNC()</C> and <C>DiagonalDecompositionNC()</C> instead of <C>UnipotentDecompositionWithTi()</C>, <C>PermSLP()</C> and <C>DiagonalDecomposition()</C>.
                </Description>
                </ManSection>
  
                </Section>
        
                <Section><Heading>Local functions for UnipotentDecomposition</Heading>
                <Label Name="Local"/>
                
                <ManSection>
                <Func Name="TransvectionAtAlpha" Arg="alpha" />
                <Returns>A list of instructions to evaluate diam (if slp was Input then this instructions are added to slp), the identity matrix</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Let slp be the list of instructions in UnipotentDecomposition and Tipos
                    denote the slots where transvections <M>t_{i,j}(\omega^{ell})</M> for
                    <M>0 \leq ell \leq \neq f</M>
                    are saved. This function computes
                    <M>t_{i,j}(\alpha) = \prod t_{i,j}(\omega^{ell})^{a_{ell}}</M>  <Cite Key="CR1" Where="4.2"/>
                    where the exponents <M>a_{ell}</M> are given by <C>CoefficientsPrimitiveElement()</C>.
                    [<Ref Sect="CoefficientsPrimitiveElement"/>]
                    <Cite Key="CR1" Where="p11"/>
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="ShiftTransvections" Arg="i"/>
                <Returns>No output</Returns>
                <Description>
                    Let Ti be the set of transvections <M>{ t_{i,i-1}(\omega^{ell}) }</M> and
                    Ti_1 the set of transvections <M>{ t_{i-1,i-2}(\omega^{ell}) }</M>.<P/>

                    ShiftTransvections computes <M>{ t_{i+1,i}(\omega^{ell}) }</M> for given Ti
                    and Ti_1 <Cite Key="CR1" Where="p12"/>,
                    stores them in the variable Ti and stores
                    the transvections  <M>{ t_{i,i-1}(\omega^{ell}) }</M> in the variable Ti_1.<P/>

                    This corresponds to <Cite Key="CR1" Where="eq (7+8) p12 "/>.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="FastShiftTransvecions" Arg="i"/>
                <Returns>No output</Returns>
                <Description>
                    Given <M>t_{2,1}</M> we compute <M>t_{i,i-1}</M> using fast exponentation.
                    This algorithm will be called in each step of the main loop and
                    is more efficient than calling ShiftTransvections
                    [<Ref Sect="ShiftTransvections"/>] (r-2) times.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="BackShiftTransvections" Arg="i"/>
                <Returns>No output</Returns>
                <Description>
                    This function is very similar to ShiftTransvections [<Ref Sect="ShiftTransvections"/>],
                    except it works in the reverse order, namely
                    BackShiftTransvections computes <M>t_{i+1,i}</M>
                    given <M>t_{i+2,i}</M> and <M>t_{i+3,i+2}</M>.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="FastBackShiftTransvections" Arg="i"/>
                <Returns>No output</Returns>
                <Description>
                    As for ShiftTransvections [<Ref Sect="ShiftTransvections"/>] ,
                    we need an efficient way to compute
                    BackShiftTransvections
                    [<Ref Sect="BackShiftTransvections"/>] multiple times in a row.
                </Description>
                </ManSection>
                
                </Section>
                
                <Section><Heading>Local functions for UnipotentDecompositionWithTi</Heading>
                <Label Name="LocalWithTi"/>
                
                <ManSection>
                <Func Name="TransvectionAtAlpha2" Arg="i, alpha" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="ComputeAllTransvections" Arg=" " />
                <Returns>No output.</Returns>
                <Description>
                    We first compute all the Ti for <M>i \geq 3</M> and add them to the SLP.
                    This are eq (7) and (8) p12 in References <Cite Key="CR1" Where="eq (7+8) p12 "/>.
                    used instead of Schift- and BackshiftTransvections
                    [<Ref Sect="ShiftTransvections"/> and <Ref Sect="BackShiftTransvections"/>].
                </Description>
                </ManSection>
                
                </Section>

    </Chapter>
    
    
    <Chapter Label="BDSU"><Heading>Bruhat Decomposition for the special unitary group (SU)</Heading>
    
        In progress.
        
        <Section><Heading>Functions</Heading>
                <Label Name="Functions for SU"/>
                
                <ManSection>
                <Func Name="LGOStandardGensSU" Arg="i, alpha" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="UnitriangularDecompositionSUEven" Arg="i, alpha" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="UnitriangularDecompositionSUOdd" Arg="i, alpha" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="UnitriangularDecompositionSU" Arg="i, alpha" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="CoefficientsPrimitiveElementS" Arg="i, alpha" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="BruhatDecompositionSU" Arg="gens, g" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="MonomialSLPSUOdd" Arg="arg" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="MonomialSLPSUEven" Arg="arg" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="CheckContinue" Arg="i, alpha" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="CycleFromPermutation" Arg="i, alpha" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="CycleFromListMine" Arg="i, alpha" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="DiagSLPSUOdd" Arg="i, alpha" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="DiagSLPSU" Arg="i, alpha" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="DiagSLPSUEven" Arg="i, alpha" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
        </Section>
    
    </Chapter>
    
    
    <Chapter Label="BDSp"><Heading>Bruhat Decomposition for the symplectic group (Sp)</Heading>
        
        In progress.
        
        <Section><Heading>Functions</Heading>
                <Label Name="Functions for Sp"/>
                
                <ManSection>
                <Func Name="LGOStandardGensSp" Arg="i, alpha" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="UnitriangularDecompositionSp" Arg="arg" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="MonomialSLPSp" Arg="arg" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="DiagSLPSp" Arg="arg" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
                <ManSection>
                <Func Name="BruhatDecompositionSp" Arg="gens, g" />
                <Returns>true</Returns>
                <Description>
                    Let <M>\alpha \in GF(p^f)</M>, <M>\alpha = \sum a_l \omega^l</M>, <M>\omega</M> a
                    primitive element.
                    Suppose further that Tipos is a list of transvections
                    of the form <M>{ t_{i,i-1}(\omega^{ell}) }</M>,<M> 2 \leq i \leq d</M>,
                    <M>0 \leq ell \leq \neq f</M>.
                    Then this function computes <M>t_{i,i-1}( \alpha )</M> by (Lemma 4.2)
                    and saves the result in tvpos.
                </Description>
                </ManSection>
                
        </Section>
    
    </Chapter>
    
    
    <Chapter Label="BDSO"><Heading>Bruhat Decomposition for the special orthogonal group (SO)</Heading>
    
        In progress.
        
        <Section><Heading>Functions</Heading>
                <Label Name="Functions for SO"/>
                
        </Section>
    
    </Chapter>
    

</Body>

<Bibliography Databases="examplebib.xml" Style="alpha"/>

</Book>


