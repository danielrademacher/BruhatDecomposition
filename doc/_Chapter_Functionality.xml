<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Functionality">
<Heading>Functionality</Heading>

<P/>
<Section Label="Chapter_Functionality_Section_Example_Methods">
<Heading>Example Methods</Heading>

<P/>
 This section will describe the example
 methods of BruhatDecomposition
 <Chapter Label="BDSL"><Heading>Bruhat Decomposition for the special linear group (SL)</Heading>
<P/>
    This implementation follows the ideas of "Straight-line programs with memory and matrix Bruhat decomposition"
    by Alice Niemeyer, Tomasz Popiel and Cheryl Praeger.<P/>
<P/>
    Let <M>g \in SL(d,p^f)</M>.
    The Bruhat Decomposition computes <M>g = u_1 \cdot w \cdot u_2</M>, where
    <List>
        <Item>
        <M>u_1,u_2</M> are lower unitriangular matrices<P/>
        </Item>
        <Item>
        <M>w</M> is monomial matrix<P/>
        </Item>
    </List>
<P/>
    In this algorithm we want to compute the Bruhat-Decomposition of <M>g</M>
    and give <M>g</M> (respectively <M>u_1,w</M> and <M>u_2</M>) as word in the
    "LGO standard generators". This generators can be found in "Constructive Recognition of Classical Groups in odd characteristic" by C. R. Leedham-Green and E. A. O’Brien. <Cite Key="CR1" Where="Chapter 3.1"/>
<P/>
    <List>
    <Item> 1) While computing <M>u_1</M> (resp <M>u_2</M>) with some kind of Gauß-Algorithm,
    we express the matrices as product of transvections.
    For <M> 1 \leq j \leq \neq  i \leq d: t_{i,j}(\alpha) </M> is the matrix <M>T</M> with 1-entries on diagonal, <M>T_{i,j} = \alpha</M>, 0 elsewhere.
    Each <M>t_{i,j}(\alpha)</M> can be computed from <M>t_{2,1}(\alpha)</M> via recursion,
    where we have to distinguish the odd and even dimensons <Cite Key="CR1" Where="Lemma 4.2"/>.
    This again can be expressed as a product of <M>t_{2,1}(\omega^{ell})</M>
    (where <M>\omega</M> is a primitive element and <M>0 \leq ell \leq \neq f</M>).
    The transvections as words in the standard generators are described in
    <Cite Key="CR1" Where="Lemma 4.2"/>.
    This yields a decomposition of <M>u_1</M> and <M>u_2</M> in standard generators.</Item>
    <Item>2) In a further step we will decompose the monomial Matrix <M>w</M>
    in a "product of permutations" and a diagonal Matrix.
    ( How to associate this product of permutations with a product
    of generators is further described in "Implemented Subfunctions (Part I)" [<Ref Sect="FirstSect"/>]
    and "Decomposing the Monomial Matrix (Part III)" [<Ref Sect="FourthSect"/>] ). </Item>
    <Item>3) The last step is the decomposition of the diagonal Matrix in 2)
    as a word in the standard generators.</Item>
    </List>
<P/>
    We won't do this matrix multiplications directly, but write them
    in a list to evaluate in a StraightLineProgram. <Cite Key="CR1" Where="Section 2"/>
    Although described differently in the paper, we sometimes will allow
    instructions to multiply more than two elements (eg during conjugating).
    This doesn't affect the optimality of an SLP much, but higly increases
    the readability of our implementation.<P/>
<P/>
    <Label Name="ThreeBack"/>
    <Section Label="FirstSect"><Heading>Implemented Subfunctions (Part I)</Heading>
<P/>
    Later we will need some additional functions. Why they are needed and where they are needed is described here. <P/>
<P/>
    <List>
    <Item> <C>MakeSLP()</C>: After the <C>BruhatDecomposition()</C> we get a list of instructions to calculate the matrices we want using the LGO standard generators. <C>MakeSLP()</C> is used to get a SLP out of these instructions.</Item>
    <Item> <C>CoefficientsPrimitiveElement()</C>: It expresses an element w in a field fld as a linear combination of a Primitive Element. This is important for the transvections. <Cite Key="CR1" Where="Lemma 4.2"/></Item>
    <Item> <C>MyPermutationMat()</C>: Turns a permutation into a permutation matrix. We need it to calculate the LGO standard generator. </Item>
    <Item> <C>LGOStandardGens()</C>: This function computes the standard generators of SL
                    as given by C. R. Leedham-Green and E. A. O'Brien in
                    "Constructive Recognition of Classical Groups  in odd characteristic".
                    <Cite Key="CR1" Where="Chapter 3.1"/> <P/>
                    </Item>
    <Item> <C>HighestSlotOfSLP()</C>: The following function determines the highest slot of a  SLP constructed from the list slp will write in. This is important to glue SLPs together. </Item>
    <Item> <C>MatToWreathProd()</C> and <C>WreathProdToMat()</C>:
        In <C>PermSLP()</C> [<Ref Sect="PermSLP"/>] we want to transform the monomial matrix <M>w</M> given by
        <C>UnipotentDecomposition()</C> into a diagonal matrix.
        (The exact procedure is described in <C>PermSLP()</C> [<Ref Sect="PermSLP"/>])<P/>
        Since multiplying the LGO standard-generators <M>s,v</M> and <M>x</M> not only involves
        permutations but we also have to consider which non-zero entries are <M>+1</M> and
        which <M>-1</M>, we want to associate this matrices with permutations on <M>2d</M> points. (cf. Wreath-Product)<P/>
<P/>
        <M>[s,v,x] \to Sym(2d), M \to </M> <C>Mwr</C> where
        <M>i^{Mwr} =  j</M>  and <M>(i+d)^{Mwr}= j+d</M> if <M> M_{i,j} = 1</M> and
        <M>i^{Mwr} = j+d</M> and <M>(i+d)^{Mwr}=  j</M>  if <M>M_{i,j} = -1</M>
        for <M>1 \leq i \leq d</M>.<P/>
<P/>
        Due to their relation to wreath-products, we will call denote the image
        of a matrix <C>M</C><M> \in [s,v,x] </M> by <C>Mwr</C>. <P/>
<P/>
        In fact the association from <C>MatToWreathProd()</C> [<Ref Sect="MatToWreathProd"/>] is an isomorphism and we can associate to each
        permutation we compute during <C>PermSLP()</C> [<Ref Sect="PermSLP"/>] a signed permutation matrix (a monomial matrix with only <M>+1</M> and <M>-1</M> as non-zero entries). <P/>
<P/>
        <M>M_{i,j} = 1</M>  if <M>i^{Mwr} =  j \leq d</M> and
        <M>M_{i,j} = -1</M> if <M>i^{Mwr} = j+d</M>
    </Item>
    <Item> <C>AEM()</C>: Write instructions for Ancient Egyptian Multiplication in slp. At several occasions we will need to compute a high power of some value saved in a memory slot.</Item>
    <Item> <C>TestIfMonomial()</C>: Tests if a given matrix M is monomial matrix. We use it to decide whether we are already finished in <C>UnipotentDecomposition()</C>.</Item>
    </List>
<P/>
    For some functions also exist a NC version. See [<Ref Sect="SixtSect"/>].
<P/>
    </Section>
<P/>
    <Section Label="ThirdSect"><Heading>UnipotentDecomposition (Part II - a)</Heading>
<P/>
    In this section is the <C>UnipotentDecomposition()</C> described. This method is used to compute the
    Unitriangular decomposition of the matrix <M>g</M>. [<Ref Sect="UnipotentDecomposition"/>] <P/>
<P/>
    For this we use five local functions in the <C>UnipotentDecomposition()</C>. They are
    <C>TransvecAtAlpha()</C>,
    <C>ShiftTransvections()</C>, <C>FastShiftTransvections()</C>, <C>BackShiftTransvections()</C> and
    <C>FastBackShiftTransvections()</C>.
    For further information to these functions look at [<Ref Sect="Local"/>]. <P/>
<P/>
    The difference to <C>UnipotentDecompositionWithTi()</C> [<Ref Sect="ThirdSect2"/>] is that this
    version won't store all the transvections <M>t_{i,i-1}(\omega^l)</M>.
    This will increase the runtime but reduce the memory usage by <M>(d-3) \cdot f</M> compared to
    the <C>UnipotentDecompositionWithTi()</C>.<P/>
<P/>
    The function can be called for example by
<Log>
gap> d := 3;;
gap> q := 5;;
gap> L := SL(d, q);;
gap> m := PseudoRandom(L);;
gap> stdgens := LGOStandardGens(d, q);;
gap> UnipotentDecomposition( stdgens, g);;
</Log>
<P/>
    </Section>
<P/>
    <Section Label="ThirdSect2"><Heading>UnipotentDecomposition saving Transvections (Part II - b)</Heading>
<P/>
    In this section is the <C>UnipotentDecompositionWithTi()</C> described.
    This method is used to compute the
    Unitriangular decomposition of the matrix <M>g</M>. [<Ref Sect="UnipotentDecompositionWithTi"/>] <P/>
<P/>
    In this version we will store all the transvections <M>t_{i,i-1}(\omega^l)</M>.
    This will increase the memory usage by <M>(d-3) \cdot f</M> but reduce runtime.<P/>
<P/>
    In <C>UnipotentDecompositionWithTi()</C> we use two local functions. They are
    <C>TransvectionAtAlpha()</C> and
    <C>ComputeAllTransvections()</C>. For further information to these functions look
    at [<Ref Sect="LocalWithTi"/>]. <P/>
<P/>
    The function can be called for example by
<Log>
gap> d := 3;;
gap> q := 5;;
gap> L := SL(d, q);;
gap> m := PseudoRandom(L);;
gap> stdgens := LGOStandardGens(d, q);;
gap> UnipotentDecompositionWithTi( stdgens, g);;
</Log>
<P/>
    </Section>
<P/>
    <Section Label="FourthSect"><Heading>Decomposing the Monomial Matrix (Part III)</Heading>
<P/>
    We use three functions to decompose the monomial matrix <M>w</M> we get from
    <C>UnipotentDecomposition()</C>. They are:
    <List>
        <Item> <C>PermutationMonomialMatrix()</C>: Find the permutation (in Sym(d) corresponding to the monomial matrix <M>w</M>) and <M>diag</M> a diagonal matrix, where <M>diag[i]</M> is the non-zero entry of row <M>i</M>. [<Ref Sect="PermutationMonomialMatrix"/>] </Item>
        <Item> <C>PermSLP()</C>:
        In this function we will transform a monomial matrix <M>w \in </M>SL<M>(d,q)</M> into a diagonal matrix <M>diag</M>. Using only the standard-generators <M>s,v,x</M>. This will lead to a monomial matrix <M>p_{sign}</M> with only <M>\pm 1</M> in non-zero entries and <M>p_{sign} \cdot diag = w</M> (i.e. <M>diag = (p_{sign})^{-1} \cdot w</M> ).<P/>
                Furthermore we will return list <C>slp</C> of instructions which will (when evaluated at the LGO standard-generators) yield <M>diag</M>.
<P/>
            It is sufficient for <M>diag</M> to be diagonal, if the permutation associated with <M>w</M> (i.e. <M>i^{\pi_w} = j</M> if <M>M_{i,j} \neq 0</M>) is the inverse of the permutation associated to <M>p_{sign}</M> (again only to Sym(<M>d</M>) ).<P/>
<P/>
            In <C>PermSLP()</C> we thus transform <M>\pi_w</M> to <M>()</M> using only <M>\{ \pi_s, \pi_v, \pi_x \}</M>.
            In order to know <M>diag</M> without computing all matrix multiplications, (we don't know the signs of <M>p_{sign}</M>), we compute a second permutation simultaneously (here using their identification with permutations in Sym<M>(2d)</M> and identifying <M>\{ \pi_s, \pi_v, \pi_x \}</M> with <M>\{s,v,x\}</M> ). [<Ref Sect="PermSLP"/>] </Item>
        <Item> <C>DiagonalDecomposition()</C>: Writes a list of instructions which evaluated on LGO standard-generators yield the diagonal matrix of the input. [<Ref Sect="DiagonalDecomposition"/>]</Item>
    </List>
<P/>
    To these three functions is also a NC version implemented. See [<Ref Sect="SixtSect"/>].
<P/>
    </Section>
<P/>
    <Section Label="FifthSect"><Heading>Main Function (Part IV)</Heading>
<P/>
    In <C>BruhatDecomposition()</C> [<Ref Sect="BruhatDecomposition"/>] we put everything together. We use the three functions <C>UnipotentDecomposition()</C> [<Ref Sect="UnipotentDecomposition"/>], <C>PermSLP()</C> [<Ref Sect="PermSLP"/>] and <C>DiagonalDecomposition()</C> [<Ref Sect="DiagonalDecomposition"/>] to compute matrices with <M>u_1^{-1} \cdot p_{sign} \cdot diag \cdot u_2^{-1} = g</M> and a SLP <C>pgr</C> that computes these matrices with the LGO standard generators.<P/>
<P/>
    Here is an exampel:
<Log>
gap> mat := [ [ Z(5)^2, Z(5)^0, Z(5)^2 ],
>             [ Z(5)^3, 0*Z(5), 0*Z(5) ],
>             [ 0*Z(5), Z(5)^2, Z(5)^2 ] ];;
gap> L := BruhatDecomposition(LGOStandardGens(3,5), mat);
gap> result := ResultOfStraightLineProgram(L[1], LGOStandardGens(3,5));
</Log>
<P/>
    <C>BruhatDecompositionWithTi()</C> [<Ref Sect="BruhatDecompositionWithTi"/>] works like <C>BruhatDecomposition()</C> [<Ref Sect="BruhatDecomposition"/>] but uses <C>UnipotentDecompositionWithTi()</C> [<Ref Sect="UnipotentDecompositionWithTi"/>] instead of <C>UnipotentDecomposition()</C> [<Ref Sect="UnipotentDecomposition"/>]. <P/>
<P/>
    You can use it in the same way like <C>BruhatDecomposition()</C>:
<Log>
gap> mat := [ [ Z(5)^2, Z(5)^0, Z(5)^2 ],
>             [ Z(5)^3, 0*Z(5), 0*Z(5) ],
>             [ 0*Z(5), Z(5)^2, Z(5)^2 ] ];;
gap> L := BruhatDecompositionWithTi(LGOStandardGens(3,5), mat);
gap> result := ResultOfStraightLineProgram(L[1], LGOStandardGens(3,5));
</Log>
<P/>
    To both functions is also a NC version implemented. See [<Ref Sect="SixtSect"/>].
<P/>
    </Section>
<P/>
    <Section Label="SixtSect"><Heading>NC Version</Heading>
<P/>
    Here is the NC version of the Bruhat Decomposition described.
    In all implemented functions are all used functions replaced through their NC version (if one exists).
    Moreover are all checks from functions of MyBruhatDecomposition removed.<P/>
<P/>
    These functions has been modified by this actions and got a NC Version:
    <List>
            <Item><C>MakeSLP()</C>[<Ref Sect="MakeSLP"/>] <M>\to</M> <C>MakeSLPNC()</C>[<Ref Sect="MakeSLPNC"/>] (uses the NC version of <C>StraightLineProgram</C>)</Item>
            <Item><C>MyPermutationMat()</C> [<Ref Sect="MyPermutationMat"/>] <M>\to</M> <C>MyPermutationMatNC()</C> [<Ref Sect="MyPermutationMatNC"/>] (uses the NC version of <C>ConvertToMatrixRep</C>)</Item>
            <Item><C>LGOStandardGens()</C> [<Ref Sect="LGOStandardGens"/>] <M>\to</M> <C>LGOStandardGensNC()</C> [<Ref Sect="LGOStandardGensNC"/>] (uses the NC version of <C>MyPermutationMat()</C>)</Item>
            <Item><C>MatToWreathProd()</C> [<Ref Sect="MatToWreathProd"/>] <M>\to</M> <C>MatToWreathProdNC()</C> [<Ref Sect="MatToWreathProdNC"/>] (no checks for user input)</Item>
            <Item><C>TestIfMonomial()</C> [<Ref Sect="TestIfMonomial"/>] <M>\to</M> <C>TestIfMonomialNC()</C> [<Ref Sect="TestIfMonomialNC"/>] (no checks for user input)</Item>
            <Item><C>UnipotentDecomposition()</C> [<Ref Sect="UnipotentDecomposition"/>] <M>\to</M> <C>UnipotentDecompositionNC()</C> [<Ref Sect="UnipotentDecompositionNC"/>] (no checks for user input)</Item>
            <Item><C>UnipotentDecompositionWithTi()</C> [<Ref Sect="UnipotentDecompositionWithTi"/>] <M>\to</M> <C>UnipotentDecompositionWithTiNC()</C> [<Ref Sect="UnipotentDecompositionWithTiNC"/>] (no checks for user input)</Item>
            <Item><C>PermutationMonomialMatrix()</C> [<Ref Sect="PermutationMonomialMatrix"/>] <M>\to</M> <C>PermutationMonomialMatrixNC()</C> [<Ref Sect="PermutationMonomialMatrixNC"/>] (no checks for user input)</Item>
            <Item><C>PermSLP()</C> [<Ref Sect="PermSLP"/>] <M>\to</M> <C>PermSLPNC()</C> [<Ref Sect="PermSLPNC"/>] (no checks for unser input and uses <C>PermutationMonomialMatrixNC()</C>)</Item>
            <Item><C>DiagonalDecomposition()</C> [<Ref Sect="DiagonalDecomposition"/>] <M>\to</M> <C>DiagonalDecompositionNC()</C> [<Ref Sect="DiagonalDecompositionNC"/>] (no checks for user input)</Item>
            <Item><C>BruhatDecomposition()</C> [<Ref Sect="BruhatDecomposition"/>] <M>\to</M> <C>BruhatDecompositionNC()</C> [<Ref Sect="BruhatDecompositionNC"/>] (uses <C>UnipotentDecompositionNC()</C>, <C>PermSLPNC()</C> and <C>DiagonalDecompositionNC</C>)</Item>
            <Item><C>BruhatDecompositionWithTi()</C> [<Ref Sect="BruhatDecompositionWithTi"/>] <M>\to</M> <C>BruhatDecompositionWithTiNC()</C> [<Ref Sect="BruhatDecompositionWithTiNC"/>] (uses <C>UnipotentDecompositionWithTiNC()</C>, <C>PermSLPNC()</C> and <C>DiagonalDecompositionNC()</C>)</Item>
    </List>
<P/>
    </Section>
<P/>
<ManSection>
  <Func Arg="arg" Name="MakeSLP" />
 <Description>
   Insert documentation for your function here
 </Description>
</ManSection>


     </Section>
     </Chapter>
</Section>


</Chapter>

